var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/isomorph.ts
var DefaultAsyncLocalStorage = class {
  constructor() {
  }
  enterWith(_) {
  }
  run(_, callback) {
    return callback();
  }
  getStore() {
    return void 0;
  }
};
var iso = {
  getRepoInfo: async (_settings) => void 0,
  getPastNAncestors: async () => [],
  getEnv: (_name) => void 0,
  getCallerLocation: () => void 0,
  newAsyncLocalStorage: () => new DefaultAsyncLocalStorage(),
  processOn: (_0, _1) => {
  }
};
var isomorph_default = iso;

// src/logger.ts
import { v4 as uuidv4 } from "uuid";
import {
  IS_MERGE_FIELD,
  TRANSACTION_ID_FIELD,
  mergeDicts,
  mergeRowBatch,
  VALID_SOURCES,
  AUDIT_SOURCE_FIELD,
  AUDIT_METADATA_FIELD,
  mergeGitMetadataSettings,
  DEFAULT_IS_LEGACY_DATASET,
  ensureDatasetRecord,
  makeLegacyEvent,
  constructJsonArray,
  SpanTypeAttribute,
  batchItems,
  SpanComponentsV3,
  SpanObjectTypeV3,
  spanObjectTypeV3ToString,
  _urljoin
} from "@braintrust/core";
import {
  BRAINTRUST_PARAMS,
  promptDataSchema,
  promptSchema,
  toolsSchema,
  gitMetadataSettingsSchema,
  BRAINTRUST_ATTACHMENT
} from "@braintrust/core/typespecs";

// src/util.ts
var GLOBAL_PROJECT = "Global";
function runCatchFinally(f, catchF, finallyF) {
  let runSyncCleanup = true;
  try {
    const ret = f();
    if (ret instanceof Promise) {
      runSyncCleanup = false;
      return ret.catch(catchF).finally(finallyF);
    } else {
      return ret;
    }
  } catch (e) {
    return catchF(e);
  } finally {
    if (runSyncCleanup) {
      finallyF();
    }
  }
}
function getCurrentUnixTimestamp() {
  return (/* @__PURE__ */ new Date()).getTime() / 1e3;
}
function isEmpty(a) {
  return a === void 0 || a === null;
}
var LazyValue = class {
  callable;
  value = {
    hasComputed: false
  };
  constructor(callable) {
    this.callable = callable;
  }
  get() {
    if (this.value.hasComputed) {
      return this.value.val;
    }
    this.value = { hasComputed: true, val: this.callable() };
    return this.value.val;
  }
  get hasComputed() {
    return this.value.hasComputed;
  }
};

// src/logger.ts
import Mustache from "mustache";
import { z as z2, ZodError } from "zod";

// src/functions/stream.ts
import {
  callEventSchema,
  sseConsoleEventDataSchema,
  sseProgressEventDataSchema
} from "@braintrust/core/typespecs";
import {
  createParser
} from "eventsource-parser";
import { z } from "zod";
var braintrustStreamChunkSchema = z.union([
  z.object({
    type: z.literal("text_delta"),
    data: z.string()
  }),
  z.object({
    type: z.literal("json_delta"),
    data: z.string()
  }),
  z.object({
    type: z.literal("error"),
    data: z.string()
  }),
  z.object({
    type: z.literal("console"),
    data: sseConsoleEventDataSchema
  }),
  z.object({
    type: z.literal("progress"),
    data: sseProgressEventDataSchema
  }),
  z.object({
    type: z.literal("start"),
    data: z.string()
  }),
  z.object({
    type: z.literal("done"),
    data: z.string()
  })
]);
var BraintrustStream = class _BraintrustStream {
  stream;
  memoizedFinalValue;
  constructor(baseStream) {
    this.stream = baseStream.pipeThrough(btStreamParser());
  }
  /**
   * Copy the stream. This returns a new stream that shares the same underlying
   * stream (via `tee`). Since streams are consumed in Javascript, use `copy()` if you
   * need to use the stream multiple times.
   *
   * @returns A new stream that you can independently consume.
   */
  copy() {
    const [newStream, copyStream] = this.stream.tee();
    this.stream = copyStream;
    return new _BraintrustStream(newStream);
  }
  /**
   * Get the underlying ReadableStream.
   *
   * @returns The underlying ReadableStream<BraintrustStreamChunk>.
   */
  toReadableStream() {
    return this.stream;
  }
  /**
   * Returns an async iterator for the BraintrustStream.
   * This allows for easy consumption of the stream using a for-await...of loop.
   *
   * @returns An async iterator that yields BraintrustStreamChunk objects.
   */
  [Symbol.asyncIterator]() {
    const reader = this.stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        if (done) {
          reader.releaseLock();
          return { done: true, value: void 0 };
        }
        return { done: false, value };
      },
      async return() {
        reader.releaseLock();
        return { done: true, value: void 0 };
      },
      async throw(error) {
        reader.releaseLock();
        throw error;
      }
    };
  }
  /**
   * Get the final value of the stream. The final value is the concatenation of all
   * the chunks in the stream, deserialized into a string or JSON object, depending on
   * the value's type.
   *
   * This function returns a promise that resolves when the stream is closed, and
   * contains the final value. Multiple calls to `finalValue()` will return the same
   * promise, so it is safe to call this multiple times.
   *
   * This function consumes the stream, so if you need to use the stream multiple
   * times, you should call `copy()` first.
   *
   * @returns A promise that resolves with the final value of the stream or `undefined` if the stream is empty.
   */
  finalValue() {
    if (this.memoizedFinalValue) {
      return this.memoizedFinalValue;
    }
    this.memoizedFinalValue = new Promise((resolve, reject) => {
      this.stream.pipeThrough(createFinalValuePassThroughStream(resolve, reject)).pipeTo(devNullWritableStream());
    });
    return this.memoizedFinalValue;
  }
};
function btStreamParser() {
  const decoder = new TextDecoder();
  let parser;
  return new TransformStream({
    async start(controller) {
      parser = createParser((event) => {
        if (event.type === "reconnect-interval") {
          return;
        }
        const parsed = callEventSchema.safeParse(event);
        if (!parsed.success) {
          throw new Error(`Failed to parse event: ${parsed.error}`);
        }
        switch (parsed.data.event) {
          case "text_delta":
            controller.enqueue({
              type: "text_delta",
              data: JSON.parse(event.data)
            });
            break;
          case "json_delta":
            controller.enqueue({
              type: "json_delta",
              data: event.data
            });
            break;
          case "error":
            controller.enqueue({
              type: "error",
              data: JSON.parse(event.data)
            });
            break;
          case "progress":
            controller.enqueue({
              type: "progress",
              data: sseProgressEventDataSchema.parse(JSON.parse(event.data))
            });
            break;
          case "console":
            controller.enqueue({
              type: "console",
              data: sseConsoleEventDataSchema.parse(JSON.parse(event.data))
            });
            break;
          case "start":
            controller.enqueue({
              type: "start",
              data: ""
            });
            break;
          case "done":
            controller.enqueue({
              type: "done",
              data: ""
            });
            break;
          default: {
            const _event = parsed.data;
            throw new Error(`Unknown event type ${JSON.stringify(_event)}`);
          }
        }
      });
    },
    async transform(chunk, controller) {
      if (chunk instanceof Uint8Array) {
        parser.feed(decoder.decode(chunk));
      } else if (typeof chunk === "string") {
        parser.feed(chunk);
      } else {
        controller.enqueue(chunk);
      }
    },
    async flush(controller) {
      controller.terminate();
    }
  });
}
function createFinalValuePassThroughStream(onFinal, onError) {
  const decoder = new TextDecoder();
  const textChunks = [];
  const jsonChunks = [];
  const transformStream = new TransformStream({
    transform(chunk, controller) {
      if (typeof chunk === "string") {
        textChunks.push(chunk);
        controller.enqueue({
          type: "text_delta",
          data: chunk
        });
      } else if (chunk instanceof Uint8Array) {
        textChunks.push(decoder.decode(chunk));
        controller.enqueue({
          type: "text_delta",
          data: decoder.decode(chunk)
        });
      } else if (braintrustStreamChunkSchema.safeParse(chunk).success) {
        const chunkType = chunk.type;
        switch (chunkType) {
          case "text_delta":
            textChunks.push(chunk.data);
            break;
          case "json_delta":
            jsonChunks.push(chunk.data);
            break;
          case "error":
            onError(chunk.data);
            break;
          case "progress":
          case "start":
          case "done":
          case "console":
            break;
          default:
            const _type = chunkType;
            throw new Error(`Unknown chunk type ${_type}`);
        }
        controller.enqueue(chunk);
      } else {
        throw new Error(`Unknown chunk type ${chunk}`);
      }
    },
    flush(controller) {
      if (jsonChunks.length > 0) {
        onFinal(JSON.parse(jsonChunks.join("")));
      } else if (textChunks.length > 0) {
        onFinal(textChunks.join(""));
      } else {
        onFinal(void 0);
      }
      controller.terminate();
    }
  });
  return transformStream;
}
function devNullWritableStream() {
  return new WritableStream({
    write(chunk) {
    },
    close() {
    },
    abort(reason) {
    },
    start(controller) {
    }
  });
}

// src/logger.ts
import { waitUntil } from "@vercel/functions";
var NoopSpan = class {
  id;
  kind = "span";
  constructor() {
    this.id = "";
  }
  log(_) {
  }
  logFeedback(_event) {
  }
  traced(callback, _1) {
    return callback(this);
  }
  startSpan(_1) {
    return this;
  }
  end(args) {
    return args?.endTime ?? getCurrentUnixTimestamp();
  }
  async export() {
    return "";
  }
  async permalink() {
    return "";
  }
  async flush() {
  }
  close(args) {
    return this.end(args);
  }
  setAttributes(_args) {
  }
};
var NOOP_SPAN = new NoopSpan();
var loginSchema = z2.strictObject({
  appUrl: z2.string(),
  appPublicUrl: z2.string(),
  orgName: z2.string(),
  apiUrl: z2.string(),
  proxyUrl: z2.string(),
  loginToken: z2.string(),
  orgId: z2.string().nullish(),
  gitMetadataSettings: gitMetadataSettingsSchema.nullish()
});
var stateNonce = 0;
var BraintrustState = class _BraintrustState {
  constructor(loginParams) {
    this.loginParams = loginParams;
    this.id = `${(/* @__PURE__ */ new Date()).toLocaleString()}-${stateNonce++}`;
    this.currentExperiment = void 0;
    this.currentLogger = void 0;
    this.currentSpan = isomorph_default.newAsyncLocalStorage();
    if (loginParams.fetch) {
      this.fetch = loginParams.fetch;
    }
    const defaultGetLogConn = async () => {
      await this.login({});
      return this.apiConn();
    };
    this._bgLogger = new BackgroundLogger(
      new LazyValue(defaultGetLogConn),
      loginParams
    );
    this.resetLoginInfo();
  }
  id;
  currentExperiment;
  // Note: the value of IsAsyncFlush doesn't really matter here, since we
  // (safely) dynamically cast it whenever retrieving the logger.
  currentLogger;
  currentSpan;
  // Any time we re-log in, we directly update the apiConn inside the logger.
  // This is preferable to replacing the whole logger, which would create the
  // possibility of multiple loggers floating around, which may not log in a
  // deterministic order.
  _bgLogger;
  appUrl = null;
  appPublicUrl = null;
  loginToken = null;
  orgId = null;
  orgName = null;
  apiUrl = null;
  proxyUrl = null;
  loggedIn = false;
  gitMetadataSettings;
  fetch = globalThis.fetch;
  _appConn = null;
  _apiConn = null;
  _proxyConn = null;
  resetLoginInfo() {
    this.appUrl = null;
    this.appPublicUrl = null;
    this.loginToken = null;
    this.orgId = null;
    this.orgName = null;
    this.apiUrl = null;
    this.proxyUrl = null;
    this.loggedIn = false;
    this.gitMetadataSettings = void 0;
    this._appConn = null;
    this._apiConn = null;
    this._proxyConn = null;
  }
  copyLoginInfo(other) {
    this.appUrl = other.appUrl;
    this.appPublicUrl = other.appPublicUrl;
    this.loginToken = other.loginToken;
    this.orgId = other.orgId;
    this.orgName = other.orgName;
    this.apiUrl = other.apiUrl;
    this.proxyUrl = other.proxyUrl;
    this.loggedIn = other.loggedIn;
    this.gitMetadataSettings = other.gitMetadataSettings;
    this._appConn = other._appConn;
    this._apiConn = other._apiConn;
    this._proxyConn = other._proxyConn;
  }
  serialize() {
    if (!this.loggedIn) {
      throw new Error(
        "Cannot serialize BraintrustState without being logged in"
      );
    }
    if (!this.appUrl || !this.appPublicUrl || !this.apiUrl || !this.proxyUrl || !this.orgName || !this.loginToken || !this.loggedIn) {
      throw new Error(
        "Cannot serialize BraintrustState without all login attributes"
      );
    }
    return {
      appUrl: this.appUrl,
      appPublicUrl: this.appPublicUrl,
      loginToken: this.loginToken,
      orgId: this.orgId,
      orgName: this.orgName,
      apiUrl: this.apiUrl,
      proxyUrl: this.proxyUrl,
      gitMetadataSettings: this.gitMetadataSettings
    };
  }
  static deserialize(serialized, opts) {
    const serializedParsed = loginSchema.safeParse(serialized);
    if (!serializedParsed.success) {
      throw new Error(
        `Cannot deserialize BraintrustState: ${serializedParsed.error.errors}`
      );
    }
    const state = new _BraintrustState({ ...opts });
    for (const key of Object.keys(loginSchema.shape)) {
      state[key] = serializedParsed.data[key];
    }
    if (!state.loginToken) {
      throw new Error(
        "Cannot deserialize BraintrustState without a login token"
      );
    }
    state.apiConn().set_token(state.loginToken);
    state.apiConn().make_long_lived();
    state.appConn().set_token(state.loginToken);
    if (state.proxyUrl) {
      state.proxyConn().make_long_lived();
      state.proxyConn().set_token(state.loginToken);
    }
    state.loggedIn = true;
    state.loginReplaceApiConn(state.apiConn());
    return state;
  }
  setFetch(fetch2) {
    this.loginParams.fetch = fetch2;
    this.fetch = fetch2;
    this._apiConn?.setFetch(fetch2);
    this._appConn?.setFetch(fetch2);
  }
  async login(loginParams) {
    if (this.apiUrl && !loginParams.forceLogin) {
      return;
    }
    const newState = await loginToState({
      ...this.loginParams,
      ...Object.fromEntries(
        Object.entries(loginParams).filter(([k, v]) => !isEmpty(v))
      )
    });
    this.copyLoginInfo(newState);
  }
  appConn() {
    if (!this._appConn) {
      if (!this.appUrl) {
        throw new Error("Must initialize appUrl before requesting appConn");
      }
      this._appConn = new HTTPConnection(this.appUrl, this.fetch);
    }
    return this._appConn;
  }
  apiConn() {
    if (!this._apiConn) {
      if (!this.apiUrl) {
        throw new Error("Must initialize apiUrl before requesting apiConn");
      }
      this._apiConn = new HTTPConnection(this.apiUrl, this.fetch);
    }
    return this._apiConn;
  }
  proxyConn() {
    if (!this.proxyUrl) {
      return this.apiConn();
    }
    if (!this._proxyConn) {
      if (!this.proxyUrl) {
        throw new Error("Must initialize proxyUrl before requesting proxyConn");
      }
      this._proxyConn = new HTTPConnection(this.proxyUrl, this.fetch);
    }
    return this._proxyConn;
  }
  bgLogger() {
    return this._bgLogger;
  }
  // Should only be called by the login function.
  loginReplaceApiConn(apiConn) {
    this._bgLogger.internalReplaceApiConn(apiConn);
  }
};
var _globalState;
function _internalSetInitialState() {
  if (_globalState) {
    throw new Error("Cannot set initial state more than once");
  }
  _globalState = globalThis.__inherited_braintrust_state || new BraintrustState({
    /*empty login options*/
  });
}
var _internalGetGlobalState = () => _globalState;
var FailedHTTPResponse = class extends Error {
  status;
  text;
  data;
  constructor(status, text, data = null) {
    super(`${status}: ${text}`);
    this.status = status;
    this.text = text;
    this.data = data;
  }
};
async function checkResponse(resp) {
  if (resp.ok) {
    return resp;
  } else {
    throw new FailedHTTPResponse(
      resp.status,
      resp.statusText,
      await resp.text()
    );
  }
}
var HTTPConnection = class _HTTPConnection {
  base_url;
  token;
  headers;
  fetch;
  constructor(base_url, fetch2) {
    this.base_url = base_url;
    this.token = null;
    this.headers = {};
    this._reset();
    this.fetch = fetch2;
  }
  setFetch(fetch2) {
    this.fetch = fetch2;
  }
  async ping() {
    try {
      const resp = await this.get("ping");
      return resp.status === 200;
    } catch (e) {
      return false;
    }
  }
  make_long_lived() {
    this._reset();
  }
  static sanitize_token(token) {
    return token.trim();
  }
  set_token(token) {
    token = _HTTPConnection.sanitize_token(token);
    this.token = token;
    this._reset();
  }
  // As far as I can tell, you cannot set the retry/backoff factor here
  _reset() {
    this.headers = {};
    if (this.token) {
      this.headers["Authorization"] = `Bearer ${this.token}`;
    }
  }
  async get(path, params = void 0, config) {
    const { headers, ...rest } = config || {};
    const url = new URL(_urljoin(this.base_url, path));
    url.search = new URLSearchParams(
      params ? Object.entries(params).filter(([_, v]) => v !== void 0).flatMap(
        ([k, v]) => v !== void 0 ? typeof v === "string" ? [[k, v]] : v.map((x) => [k, x]) : []
      ) : []
    ).toString();
    const this_fetch = this.fetch;
    const this_headers = this.headers;
    return await checkResponse(
      // Using toString() here makes it work with isomorphic fetch
      await this_fetch(url.toString(), {
        headers: {
          Accept: "application/json",
          ...this_headers,
          ...headers
        },
        keepalive: true,
        ...rest
      })
    );
  }
  async post(path, params, config) {
    const { headers, ...rest } = config || {};
    const this_fetch = this.fetch;
    const this_base_url = this.base_url;
    const this_headers = this.headers;
    return await checkResponse(
      await this_fetch(_urljoin(this_base_url, path), {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          ...this_headers,
          ...headers
        },
        body: typeof params === "string" ? params : params ? JSON.stringify(params) : void 0,
        keepalive: true,
        ...rest
      })
    );
  }
  async get_json(object_type, args = void 0, retries = 0) {
    const tries = retries + 1;
    for (let i = 0; i < tries; i++) {
      try {
        const resp = await this.get(`${object_type}`, args);
        return await resp.json();
      } catch (e) {
        if (i < tries - 1) {
          console.log(
            `Retrying API request ${object_type} ${JSON.stringify(args)} ${e.status} ${e.text}`
          );
          continue;
        }
        throw e;
      }
    }
  }
  async post_json(object_type, args = void 0) {
    const resp = await this.post(`${object_type}`, args, {
      headers: { "Content-Type": "application/json" }
    });
    return await resp.json();
  }
};
var Attachment = class {
  /**
   * The object that replaces this `Attachment` at upload time.
   */
  reference;
  uploader;
  _data;
  state;
  // For debug logging only.
  dataDebugString;
  /**
   * Construct an attachment.
   *
   * @param data A string representing the path of the file on disk, or a
   * `Blob`/`ArrayBuffer` with the file's contents. The caller is responsible
   * for ensuring the file/blob/buffer is not modified until upload is complete.
   *
   * @param filename The desired name of the file in Braintrust after uploading.
   * This parameter is for visualization purposes only and has no effect on
   * attachment storage.
   *
   * @param contentType The MIME type of the file.
   *
   * @param state (Optional) For internal use.
   */
  constructor({ data, filename, contentType, state }) {
    this.reference = {
      type: BRAINTRUST_ATTACHMENT,
      filename,
      content_type: contentType,
      key: newId()
    };
    this.state = state;
    this.dataDebugString = typeof data === "string" ? data : "<in-memory data>";
    this._data = this.initData(data);
    this.uploader = this.initUploader();
  }
  /**
   * On first access, (1) reads the attachment from disk if needed, (2)
   * authenticates with the data plane to request a signed URL, (3) uploads to
   * object store, and (4) updates the attachment.
   *
   * @returns The attachment status.
   */
  async upload() {
    return await this.uploader.get();
  }
  /**
   * The attachment contents. This is a lazy value that will read the attachment contents from disk or memory on first access.
   */
  async data() {
    return this._data.get();
  }
  /**
   * A human-readable description for logging and debugging.
   *
   * @returns The debug object. The return type is not stable and may change in
   * a future release.
   */
  debugInfo() {
    return {
      inputData: this.dataDebugString,
      reference: this.reference,
      state: this.state
    };
  }
  initUploader() {
    const doUpload = async (conn, orgId) => {
      const requestParams = {
        key: this.reference.key,
        filename: this.reference.filename,
        content_type: this.reference.content_type,
        org_id: orgId
      };
      const [metadataPromiseResult, dataPromiseResult] = await Promise.allSettled([
        conn.post("/attachment", requestParams),
        this._data.get()
      ]);
      if (metadataPromiseResult.status === "rejected") {
        const errorStr = JSON.stringify(metadataPromiseResult.reason);
        throw new Error(
          `Failed to request signed URL from API server: ${errorStr}`
        );
      }
      if (dataPromiseResult.status === "rejected") {
        const errorStr = JSON.stringify(dataPromiseResult.reason);
        throw new Error(`Failed to read file: ${errorStr}`);
      }
      const metadataResponse = metadataPromiseResult.value;
      const data = dataPromiseResult.value;
      let signedUrl;
      let headers;
      try {
        ({ signedUrl, headers } = z2.object({
          signedUrl: z2.string().url(),
          headers: z2.record(z2.string())
        }).parse(await metadataResponse.json()));
      } catch (error) {
        if (error instanceof ZodError) {
          const errorStr = JSON.stringify(error.flatten());
          throw new Error(`Invalid response from API server: ${errorStr}`);
        }
        throw error;
      }
      let objectStoreResponse;
      try {
        objectStoreResponse = await checkResponse(
          await fetch(signedUrl, {
            method: "PUT",
            headers,
            body: data
          })
        );
      } catch (error) {
        if (error instanceof FailedHTTPResponse) {
          throw new Error(
            `Failed to upload attachment to object store: ${error.status} ${error.text} ${error.data}`
          );
        }
        throw error;
      }
      return { signedUrl, metadataResponse, objectStoreResponse };
    };
    const errorWrapper = async () => {
      const status = { upload_status: "done" };
      const state = this.state ?? _globalState;
      await state.login({});
      const conn = state.apiConn();
      const orgId = state.orgId ?? "";
      try {
        await doUpload(conn, orgId);
      } catch (error) {
        status.upload_status = "error";
        status.error_message = error instanceof Error ? error.message : JSON.stringify(error);
      }
      const requestParams = {
        key: this.reference.key,
        org_id: orgId,
        status
      };
      const statusResponse = await conn.post(
        "/attachment/status",
        requestParams
      );
      if (!statusResponse.ok) {
        const errorStr = JSON.stringify(statusResponse);
        throw new Error(`Couldn't log attachment status: ${errorStr}`);
      }
      return status;
    };
    return new LazyValue(errorWrapper);
  }
  initData(data) {
    if (typeof data === "string") {
      const readFile = isomorph_default.readFile;
      if (!readFile) {
        throw new Error(
          `This platform does not support reading the filesystem. Construct the Attachment
with a Blob/ArrayBuffer, or run the program on Node.js.`
        );
      }
      return new LazyValue(async () => new Blob([await readFile(data)]));
    } else {
      return new LazyValue(async () => new Blob([data]));
    }
  }
};
function logFeedbackImpl(state, parentObjectType, parentObjectId, {
  id,
  expected,
  scores,
  metadata: inputMetadata,
  tags,
  comment,
  source: inputSource
}) {
  const source = inputSource ?? "external";
  if (!VALID_SOURCES.includes(source)) {
    throw new Error(`source must be one of ${VALID_SOURCES}`);
  }
  if (isEmpty(scores) && isEmpty(expected) && isEmpty(tags) && isEmpty(comment)) {
    throw new Error(
      "At least one of scores, expected, tags, or comment must be specified"
    );
  }
  const validatedEvent = validateAndSanitizeExperimentLogPartialArgs({
    scores,
    metadata: inputMetadata,
    expected,
    tags
  });
  let { metadata, ...updateEvent } = deepCopyEvent(validatedEvent);
  updateEvent = Object.fromEntries(
    Object.entries(updateEvent).filter(([_, v]) => !isEmpty(v))
  );
  const parentIds = async () => new SpanComponentsV3({
    object_type: parentObjectType,
    object_id: await parentObjectId.get()
  }).objectIdFields();
  if (Object.keys(updateEvent).length > 0) {
    const record = new LazyValue(async () => {
      return {
        id,
        ...updateEvent,
        ...await parentIds(),
        [AUDIT_SOURCE_FIELD]: source,
        [AUDIT_METADATA_FIELD]: metadata,
        [IS_MERGE_FIELD]: true
      };
    });
    state.bgLogger().log([record]);
  }
  if (!isEmpty(comment)) {
    const record = new LazyValue(async () => {
      return {
        id: uuidv4(),
        created: (/* @__PURE__ */ new Date()).toISOString(),
        origin: {
          // NOTE: We do not know (or care?) what the transaction id of the row that
          // we're commenting on is here, so we omit it.
          id
        },
        comment: {
          text: comment
        },
        ...await parentIds(),
        [AUDIT_SOURCE_FIELD]: source,
        [AUDIT_METADATA_FIELD]: metadata
      };
    });
    state.bgLogger().log([record]);
  }
}
function updateSpanImpl({
  state,
  parentObjectType,
  parentObjectId,
  id,
  event
}) {
  const updateEvent = deepCopyEvent(
    validateAndSanitizeExperimentLogPartialArgs({
      id,
      ...event
    })
  );
  const parentIds = async () => new SpanComponentsV3({
    object_type: parentObjectType,
    object_id: await parentObjectId.get()
  }).objectIdFields();
  const record = new LazyValue(async () => ({
    id,
    ...updateEvent,
    ...await parentIds(),
    [IS_MERGE_FIELD]: true
  }));
  state.bgLogger().log([record]);
}
function updateSpan({
  exported,
  state,
  ...event
}) {
  const resolvedState = state ?? _globalState;
  const components = SpanComponentsV3.fromStr(exported);
  if (!components.data.row_id) {
    throw new Error("Exported span must have a row id");
  }
  updateSpanImpl({
    state: resolvedState,
    parentObjectType: components.data.object_type,
    parentObjectId: new LazyValue(
      spanComponentsToObjectIdLambda(resolvedState, components)
    ),
    id: components.data.row_id,
    event
  });
}
function spanComponentsToObjectIdLambda(state, components) {
  if (components.data.object_id) {
    const ret = components.data.object_id;
    return async () => ret;
  }
  if (!components.data.compute_object_metadata_args) {
    throw new Error(
      "Impossible: must provide either objectId or computeObjectMetadataArgs"
    );
  }
  switch (components.data.object_type) {
    case SpanObjectTypeV3.EXPERIMENT:
      throw new Error(
        "Impossible: computeObjectMetadataArgs not supported for experiments"
      );
    case SpanObjectTypeV3.PROJECT_LOGS:
      return async () => (await computeLoggerMetadata(state, {
        ...components.data.compute_object_metadata_args
      })).project.id;
    default:
      const x = components.data.object_type;
      throw new Error(`Unknown object type: ${x}`);
  }
}
async function spanComponentsToObjectId({
  components,
  state
}) {
  return await spanComponentsToObjectIdLambda(
    state ?? _globalState,
    components
  )();
}
async function permalink(slug, opts) {
  const state = opts?.state ?? _globalState;
  const getOrgName = async () => {
    if (opts?.orgName) {
      return opts.orgName;
    }
    await state.login({});
    if (!state.orgName) {
      throw new Error(
        "Must either provide orgName explicitly or be logged in to a specific org"
      );
    }
    return state.orgName;
  };
  const getAppUrl = async () => {
    if (opts?.appUrl) {
      return opts.appUrl;
    }
    await state.login({});
    if (!state.appUrl) {
      throw new Error("Must either provide appUrl explicitly or be logged in");
    }
    return state.appUrl;
  };
  const components = SpanComponentsV3.fromStr(slug);
  const object_type = spanObjectTypeV3ToString(components.data.object_type);
  const [orgName, appUrl, object_id] = await Promise.all([
    getOrgName(),
    getAppUrl(),
    spanComponentsToObjectId({ components, state })
  ]);
  const id = components.data.row_id;
  if (!id) {
    throw new Error("Span slug does not refer to an individual row");
  }
  const urlParams = new URLSearchParams({ object_type, object_id, id });
  return `${appUrl}/app/${orgName}/object?${urlParams}`;
}
function startSpanParentArgs(args) {
  let argParentObjectId = void 0;
  let argParentSpanIds = void 0;
  let argPropagatedEvent = void 0;
  if (args.parent) {
    if (args.parentSpanIds) {
      throw new Error("Cannot specify both parent and parentSpanIds");
    }
    const parentComponents = SpanComponentsV3.fromStr(args.parent);
    if (args.parentObjectType !== parentComponents.data.object_type) {
      throw new Error(
        `Mismatch between expected span parent object type ${args.parentObjectType} and provided type ${parentComponents.data.object_type}`
      );
    }
    const parentComponentsObjectIdLambda = spanComponentsToObjectIdLambda(
      args.state,
      parentComponents
    );
    const computeParentObjectId = async () => {
      const parentComponentsObjectId = await parentComponentsObjectIdLambda();
      if (await args.parentObjectId.get() !== parentComponentsObjectId) {
        throw new Error(
          `Mismatch between expected span parent object id ${await args.parentObjectId.get()} and provided id ${parentComponentsObjectId}`
        );
      }
      return await args.parentObjectId.get();
    };
    argParentObjectId = new LazyValue(computeParentObjectId);
    if (parentComponents.data.row_id) {
      argParentSpanIds = {
        spanId: parentComponents.data.span_id,
        rootSpanId: parentComponents.data.root_span_id
      };
    }
    argPropagatedEvent = args.propagatedEvent ?? (parentComponents.data.propagated_event ?? void 0);
  } else {
    argParentObjectId = args.parentObjectId;
    argParentSpanIds = args.parentSpanIds;
    argPropagatedEvent = args.propagatedEvent;
  }
  return {
    parentObjectType: args.parentObjectType,
    parentObjectId: argParentObjectId,
    parentComputeObjectMetadataArgs: args.parentComputeObjectMetadataArgs,
    parentSpanIds: argParentSpanIds,
    propagatedEvent: argPropagatedEvent
  };
}
var Logger = class {
  state;
  lazyMetadata;
  _asyncFlush;
  computeMetadataArgs;
  lastStartTime;
  lazyId;
  calledStartSpan;
  // For type identification.
  kind = "logger";
  constructor(state, lazyMetadata, logOptions = {}) {
    this.lazyMetadata = lazyMetadata;
    this._asyncFlush = logOptions.asyncFlush;
    this.computeMetadataArgs = logOptions.computeMetadataArgs;
    this.lastStartTime = getCurrentUnixTimestamp();
    this.lazyId = new LazyValue(async () => await this.id);
    this.calledStartSpan = false;
    this.state = state;
  }
  get org_id() {
    return (async () => {
      return (await this.lazyMetadata.get()).org_id;
    })();
  }
  get project() {
    return (async () => {
      return (await this.lazyMetadata.get()).project;
    })();
  }
  get id() {
    return (async () => (await this.project).id)();
  }
  parentObjectType() {
    return SpanObjectTypeV3.PROJECT_LOGS;
  }
  /**
   * Log a single event. The event will be batched and uploaded behind the scenes if `logOptions.asyncFlush` is true.
   *
   * @param event The event to log.
   * @param event.input: (Optional) the arguments that uniquely define a user input (an arbitrary, JSON serializable object).
   * @param event.output: (Optional) the output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question.
   * @param event.expected: (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models.
   * @param event.error: (Optional) The error that occurred, if any. If you use tracing to run an experiment, errors are automatically logged when your code throws an exception.
   * @param event.scores: (Optional) a dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare logs.
   * @param event.metadata: (Optional) a dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings.
   * @param event.metrics: (Optional) a dictionary of metrics to log. The following keys are populated automatically: "start", "end".
   * @param event.id: (Optional) a unique identifier for the event. If you don't provide one, BrainTrust will generate one for you.
   * @param options Additional logging options
   * @param options.allowConcurrentWithSpans in rare cases where you need to log at the top level separately from spans on the logger elsewhere, set this to true.
   * @returns The `id` of the logged event.
   */
  log(event, options) {
    if (this.calledStartSpan && !options?.allowConcurrentWithSpans) {
      throw new Error(
        "Cannot run toplevel `log` method while using spans. To log to the span, call `logger.traced` and then log with `span.log`"
      );
    }
    const span = this.startSpanImpl({ startTime: this.lastStartTime, event });
    this.lastStartTime = span.end();
    const ret = span.id;
    if (this.asyncFlush === true) {
      return ret;
    } else {
      return (async () => {
        await this.flush();
        return ret;
      })();
    }
  }
  /**
   * Create a new toplevel span underneath the logger. The name defaults to "root".
   *
   * See {@link Span.traced} for full details.
   */
  traced(callback, args) {
    const { setCurrent, ...argsRest } = args ?? {};
    const span = this.startSpan(argsRest);
    const ret = runCatchFinally(
      () => {
        if (setCurrent ?? true) {
          return withCurrent(span, callback);
        } else {
          return callback(span);
        }
      },
      (e) => {
        logError(span, e);
        throw e;
      },
      () => span.end()
    );
    if (this.asyncFlush) {
      return ret;
    } else {
      return (async () => {
        const awaitedRet = await ret;
        await this.flush();
        return awaitedRet;
      })();
    }
  }
  /**
   * Lower-level alternative to `traced`. This allows you to start a span yourself, and can be useful in situations
   * where you cannot use callbacks. However, spans started with `startSpan` will not be marked as the "current span",
   * so `currentSpan()` and `traced()` will be no-ops. If you want to mark a span as current, use `traced` instead.
   *
   * See {@link traced} for full details.
   */
  startSpan(args) {
    this.calledStartSpan = true;
    return this.startSpanImpl(args);
  }
  startSpanImpl(args) {
    return new SpanImpl({
      state: this.state,
      ...args,
      ...startSpanParentArgs({
        state: this.state,
        parent: args?.parent,
        parentObjectType: this.parentObjectType(),
        parentObjectId: this.lazyId,
        parentComputeObjectMetadataArgs: this.computeMetadataArgs,
        parentSpanIds: void 0,
        propagatedEvent: args?.propagatedEvent
      }),
      defaultRootType: SpanTypeAttribute.TASK
    });
  }
  /**
   * Log feedback to an event. Feedback is used to save feedback scores, set an expected value, or add a comment.
   *
   * @param event
   * @param event.id The id of the event to log feedback for. This is the `id` returned by `log` or accessible as the `id` field of a span.
   * @param event.scores (Optional) a dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the event.
   * @param event.expected (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not.
   * @param event.comment (Optional) an optional comment string to log about the event.
   * @param event.metadata (Optional) a dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI. Note, this metadata does not correspond to the main event itself, but rather the audit log attached to the event.
   * @param event.source (Optional) the source of the feedback. Must be one of "external" (default), "app", or "api".
   */
  logFeedback(event) {
    logFeedbackImpl(this.state, this.parentObjectType(), this.lazyId, event);
  }
  /**
   * Update a span in the experiment using its id. It is important that you only update a span once the original span has been fully written and flushed,
   * since otherwise updates to the span may conflict with the original span.
   *
   * @param event The event data to update the span with. Must include `id`. See {@link Experiment.log} for a full list of valid fields.
   */
  updateSpan(event) {
    const { id, ...eventRest } = event;
    if (!id) {
      throw new Error("Span id is required to update a span");
    }
    updateSpanImpl({
      state: this.state,
      parentObjectType: this.parentObjectType(),
      parentObjectId: this.lazyId,
      id,
      event: eventRest
    });
  }
  /**
   * Return a serialized representation of the logger that can be used to start subspans in other places.
   *
   * See {@link Span.startSpan} for more details.
   */
  async export() {
    return new SpanComponentsV3({
      object_type: this.parentObjectType(),
      ...this.computeMetadataArgs && !this.lazyId.hasComputed ? { compute_object_metadata_args: this.computeMetadataArgs } : { object_id: await this.lazyId.get() }
    }).toStr();
  }
  /*
   * Flush any pending logs to the server.
   */
  async flush() {
    return await this.state.bgLogger().flush();
  }
  get asyncFlush() {
    return this._asyncFlush;
  }
};
function castLogger(logger, asyncFlush) {
  if (logger === void 0)
    return void 0;
  if (asyncFlush !== void 0 && !!asyncFlush !== !!logger.asyncFlush) {
    throw new Error(
      `Asserted asyncFlush setting ${asyncFlush} does not match stored logger's setting ${logger.asyncFlush}`
    );
  }
  return logger;
}
function constructLogs3Data(items) {
  return `{"rows": ${constructJsonArray(items)}, "api_version": 2}`;
}
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var BackgroundLogger = class _BackgroundLogger {
  apiConn;
  items = [];
  activeFlush = Promise.resolve();
  activeFlushResolved = true;
  activeFlushError = void 0;
  onFlushError;
  syncFlush = false;
  // 6 MB for the AWS lambda gateway (from our own testing).
  maxRequestSize = 6 * 1024 * 1024;
  defaultBatchSize = 100;
  numTries = 3;
  queueDropExceedingMaxsize = void 0;
  queueDropLoggingPeriod = 60;
  failedPublishPayloadsDir = void 0;
  allPublishPayloadsDir = void 0;
  queueDropLoggingState = {
    numDropped: 0,
    lastLoggedTimestamp: 0
  };
  constructor(apiConn, opts) {
    opts = opts ?? {};
    this.apiConn = apiConn;
    const syncFlushEnv = Number(isomorph_default.getEnv("BRAINTRUST_SYNC_FLUSH"));
    if (!isNaN(syncFlushEnv)) {
      this.syncFlush = Boolean(syncFlushEnv);
    }
    const defaultBatchSizeEnv = Number(
      isomorph_default.getEnv("BRAINTRUST_DEFAULT_BATCH_SIZE")
    );
    if (!isNaN(defaultBatchSizeEnv)) {
      this.defaultBatchSize = defaultBatchSizeEnv;
    }
    const maxRequestSizeEnv = Number(isomorph_default.getEnv("BRAINTRUST_MAX_REQUEST_SIZE"));
    if (!isNaN(maxRequestSizeEnv)) {
      this.maxRequestSize = maxRequestSizeEnv;
    }
    const numTriesEnv = Number(isomorph_default.getEnv("BRAINTRUST_NUM_RETRIES"));
    if (!isNaN(numTriesEnv)) {
      this.numTries = numTriesEnv + 1;
    }
    const queueDropExceedingMaxsizeEnv = Number(
      isomorph_default.getEnv("BRAINTRUST_QUEUE_DROP_EXCEEDING_MAXSIZE")
    );
    if (!isNaN(queueDropExceedingMaxsizeEnv)) {
      this.queueDropExceedingMaxsize = queueDropExceedingMaxsizeEnv;
    }
    const queueDropLoggingPeriodEnv = Number(
      isomorph_default.getEnv("BRAINTRUST_QUEUE_DROP_LOGGING_PERIOD")
    );
    if (!isNaN(queueDropLoggingPeriodEnv)) {
      this.queueDropLoggingPeriod = queueDropLoggingPeriodEnv;
    }
    const failedPublishPayloadsDirEnv = isomorph_default.getEnv(
      "BRAINTRUST_FAILED_PUBLISH_PAYLOADS_DIR"
    );
    if (failedPublishPayloadsDirEnv) {
      this.failedPublishPayloadsDir = failedPublishPayloadsDirEnv;
    }
    const allPublishPayloadsDirEnv = isomorph_default.getEnv(
      "BRAINTRUST_ALL_PUBLISH_PAYLOADS_DIR"
    );
    if (allPublishPayloadsDirEnv) {
      this.allPublishPayloadsDir = allPublishPayloadsDirEnv;
    }
    if (!opts.noExitFlush) {
      isomorph_default.processOn("beforeExit", async () => {
        await this.flush();
      });
    }
    this.onFlushError = opts.onFlushError;
  }
  log(items) {
    const [addedItems, droppedItems] = (() => {
      if (this.queueDropExceedingMaxsize === void 0) {
        return [items, []];
      }
      const numElementsToAdd = Math.min(
        Math.max(this.queueDropExceedingMaxsize - this.items.length, 0),
        items.length
      );
      return [items.slice(0, numElementsToAdd), items.slice(numElementsToAdd)];
    })();
    this.items.push(...addedItems);
    if (!this.syncFlush) {
      this.triggerActiveFlush();
    }
    if (droppedItems.length) {
      this.registerDroppedItemCount(droppedItems.length);
      if (this.allPublishPayloadsDir || this.failedPublishPayloadsDir) {
        this.dumpDroppedEvents(droppedItems);
      }
    }
  }
  async flush() {
    if (this.syncFlush) {
      this.triggerActiveFlush();
    }
    await this.activeFlush;
    if (this.activeFlushError) {
      const err = this.activeFlushError;
      this.activeFlushError = void 0;
      if (this.syncFlush) {
        throw err;
      }
    }
  }
  async flushOnce(args) {
    const batchSize = args?.batchSize ?? this.defaultBatchSize;
    const wrappedItems = this.items;
    this.items = [];
    const [allItems, attachments] = await this.unwrapLazyValues(wrappedItems);
    if (allItems.length === 0) {
      return;
    }
    const allItemsStr = allItems.map(
      (bucket) => bucket.map((item) => JSON.stringify(item))
    );
    const batchSets = batchItems({
      items: allItemsStr,
      batchMaxNumItems: batchSize,
      batchMaxNumBytes: this.maxRequestSize / 2
    });
    for (const batchSet of batchSets) {
      const postPromises = batchSet.map(
        (batch) => (async () => {
          try {
            await this.submitLogsRequest(batch);
            return { type: "success" };
          } catch (e) {
            return { type: "error", value: e };
          }
        })()
      );
      const results = await Promise.all(postPromises);
      const failingResultErrors = results.map((r) => r.type === "success" ? void 0 : r.value).filter((r) => r !== void 0);
      if (failingResultErrors.length) {
        throw new AggregateError(
          failingResultErrors,
          `Encountered the following errors while logging:`
        );
      }
    }
    const attachmentErrors = [];
    for (const attachment of attachments) {
      try {
        const result = await attachment.upload();
        if (result.upload_status === "error") {
          throw new Error(result.error_message);
        }
      } catch (error) {
        attachmentErrors.push(error);
      }
    }
    if (attachmentErrors.length === 1) {
      throw attachmentErrors[0];
    } else if (attachmentErrors.length > 1) {
      throw new AggregateError(
        attachmentErrors,
        `Encountered the following errors while uploading attachments:`
      );
    }
    if (this.items.length > 0) {
      await this.flushOnce(args);
    }
  }
  async unwrapLazyValues(wrappedItems) {
    for (let i = 0; i < this.numTries; ++i) {
      try {
        const items = await Promise.all(wrappedItems.map((x) => x.get()));
        const attachments = [];
        items.forEach((item) => extractAttachments(item, attachments));
        return [mergeRowBatch(items), attachments];
      } catch (e) {
        let errmsg = "Encountered error when constructing records to flush";
        const isRetrying = i + 1 < this.numTries;
        if (isRetrying) {
          errmsg += ". Retrying";
        }
        console.warn(errmsg);
        if (!isRetrying) {
          console.warn(
            `Failed to construct log records to flush after ${this.numTries} attempts. Dropping batch`
          );
          throw e;
        } else {
          console.warn(e);
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }
    }
    throw new Error("Impossible");
  }
  async submitLogsRequest(items) {
    const conn = await this.apiConn.get();
    const dataStr = constructLogs3Data(items);
    if (this.allPublishPayloadsDir) {
      await _BackgroundLogger.writePayloadToDir({
        payloadDir: this.allPublishPayloadsDir,
        payload: dataStr
      });
    }
    for (let i = 0; i < this.numTries; i++) {
      const startTime = now();
      let error = void 0;
      try {
        await conn.post_json("logs3", dataStr);
      } catch {
        try {
          const legacyDataS = constructJsonArray(
            items.map((r) => JSON.stringify(makeLegacyEvent(JSON.parse(r))))
          );
          await conn.post_json("logs", legacyDataS);
        } catch (e) {
          error = e;
        }
      }
      if (error === void 0) {
        return;
      }
      const isRetrying = i + 1 < this.numTries;
      const retryingText = isRetrying ? "" : " Retrying";
      const errorText = (() => {
        if (error instanceof FailedHTTPResponse) {
          return `${error.status} (${error.text}): ${error.data}`;
        } else {
          return `${error}`;
        }
      })();
      const errMsg = `log request failed. Elapsed time: ${(now() - startTime) / 1e3} seconds. Payload size: ${dataStr.length}.${retryingText}
Error: ${errorText}`;
      if (!isRetrying && this.failedPublishPayloadsDir) {
        await _BackgroundLogger.writePayloadToDir({
          payloadDir: this.failedPublishPayloadsDir,
          payload: dataStr
        });
        this.logFailedPayloadsDir();
      }
      if (!isRetrying) {
        console.warn(
          `log request failed after ${this.numTries} retries. Dropping batch`
        );
        throw new Error(errMsg);
      } else {
        console.warn(errMsg);
        if (isRetrying) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }
    }
  }
  registerDroppedItemCount(numItems) {
    if (numItems <= 0) {
      return;
    }
    this.queueDropLoggingState.numDropped += numItems;
    const timeNow = getCurrentUnixTimestamp();
    if (timeNow - this.queueDropLoggingState.lastLoggedTimestamp > this.queueDropLoggingPeriod) {
      console.warn(
        `Dropped ${this.queueDropLoggingState.numDropped} elements due to full queue`
      );
      if (this.failedPublishPayloadsDir) {
        this.logFailedPayloadsDir();
      }
      this.queueDropLoggingState.numDropped = 0;
      this.queueDropLoggingState.lastLoggedTimestamp = timeNow;
    }
  }
  async dumpDroppedEvents(wrappedItems) {
    const publishPayloadsDir = [
      this.allPublishPayloadsDir,
      this.failedPublishPayloadsDir
    ].reduce((acc, x) => x ? acc.concat([x]) : acc, new Array());
    if (!(wrappedItems.length && publishPayloadsDir.length)) {
      return;
    }
    try {
      const [allItems, allAttachments] = await this.unwrapLazyValues(wrappedItems);
      const dataStr = constructLogs3Data(
        allItems.map((x) => JSON.stringify(x))
      );
      const attachmentStr = JSON.stringify(
        allAttachments.map((a) => a.debugInfo())
      );
      const payload = `{"data": ${dataStr}, "attachments": ${attachmentStr}}
`;
      for (const payloadDir of publishPayloadsDir) {
        await _BackgroundLogger.writePayloadToDir({ payloadDir, payload });
      }
    } catch (e) {
      console.error(e);
    }
  }
  static async writePayloadToDir({
    payloadDir,
    payload
  }) {
    if (!(isomorph_default.pathJoin && isomorph_default.mkdir && isomorph_default.writeFile)) {
      console.warn(
        "Cannot dump payloads: filesystem-operations not supported on this platform"
      );
      return;
    }
    const payloadFile = isomorph_default.pathJoin(
      payloadDir,
      `payload_${getCurrentUnixTimestamp()}_${uuidv4().slice(0, 8)}.json`
    );
    try {
      await isomorph_default.mkdir(payloadDir, { recursive: true });
      await isomorph_default.writeFile(payloadFile, payload);
    } catch (e) {
      console.error(
        `Failed to write failed payload to output file ${payloadFile}:
`,
        e
      );
    }
  }
  triggerActiveFlush() {
    if (this.activeFlushResolved) {
      this.activeFlushResolved = false;
      this.activeFlushError = void 0;
      this.activeFlush = (async () => {
        try {
          await this.flushOnce();
        } catch (err) {
          if (err instanceof AggregateError) {
            for (const e of err.errors) {
              this.onFlushError?.(e);
            }
          } else {
            this.onFlushError?.(err);
          }
          this.activeFlushError = err;
        } finally {
          this.activeFlushResolved = true;
        }
      })();
      waitUntil(this.activeFlush);
    }
  }
  logFailedPayloadsDir() {
    console.warn(`Logging failed payloads to ${this.failedPublishPayloadsDir}`);
  }
  // Should only be called by BraintrustState.
  internalReplaceApiConn(apiConn) {
    this.apiConn = new LazyValue(async () => apiConn);
  }
};
function init(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either init(project, options) or init(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  const {
    project,
    experiment,
    description,
    dataset,
    baseExperiment,
    isPublic,
    open,
    update,
    appUrl,
    apiKey,
    orgName,
    forceLogin,
    fetch: fetch2,
    metadata,
    gitMetadataSettings,
    projectId,
    baseExperimentId,
    repoInfo,
    state: stateArg
  } = options;
  if (open && update) {
    throw new Error("Cannot open and update an experiment at the same time");
  }
  const state = stateArg ?? _globalState;
  if (open) {
    if (isEmpty(experiment)) {
      throw new Error(`Cannot open an experiment without specifying its name`);
    }
    const lazyMetadata2 = new LazyValue(
      async () => {
        await state.login({ apiKey, appUrl, orgName, fetch: fetch2, forceLogin });
        const args = {
          project_name: project,
          project_id: projectId,
          org_name: state.orgName,
          experiment_name: experiment
        };
        const response = await state.appConn().post_json("api/experiment/get", args);
        if (response.length === 0) {
          throw new Error(
            `Experiment ${experiment} not found in project ${projectId ?? project}.`
          );
        }
        const info = response[0];
        return {
          project: {
            id: info.project_id,
            name: project ?? "UNKNOWN_PROJECT",
            fullInfo: {}
          },
          experiment: {
            id: info.id,
            name: info.name,
            fullInfo: info
          }
        };
      }
    );
    return new ReadonlyExperiment(
      stateArg ?? _globalState,
      lazyMetadata2
    );
  }
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({ apiKey, appUrl, orgName });
      const args = {
        project_name: project,
        project_id: projectId,
        org_id: state.orgId,
        update
      };
      if (experiment) {
        args["experiment_name"] = experiment;
      }
      if (description) {
        args["description"] = description;
      }
      const repoInfoArg = await (async () => {
        if (repoInfo) {
          return repoInfo;
        }
        let mergedGitMetadataSettings = {
          ...state.gitMetadataSettings || {
            collect: "all"
          }
        };
        if (gitMetadataSettings) {
          mergedGitMetadataSettings = mergeGitMetadataSettings(
            mergedGitMetadataSettings,
            gitMetadataSettings
          );
        }
        return await isomorph_default.getRepoInfo(mergedGitMetadataSettings);
      })();
      if (repoInfoArg) {
        args["repo_info"] = repoInfoArg;
      }
      if (baseExperimentId) {
        args["base_exp_id"] = baseExperimentId;
      } else if (baseExperiment) {
        args["base_experiment"] = baseExperiment;
      } else {
        args["ancestor_commits"] = await isomorph_default.getPastNAncestors();
      }
      if (dataset !== void 0) {
        args["dataset_id"] = await dataset.id;
        args["dataset_version"] = await dataset.version();
      }
      if (isPublic !== void 0) {
        args["public"] = isPublic;
      }
      if (metadata) {
        args["metadata"] = metadata;
      }
      let response = null;
      while (true) {
        try {
          response = await state.appConn().post_json("api/experiment/register", args);
          break;
        } catch (e) {
          if (args["base_experiment"] && `${"data" in e && e.data}`.includes("base experiment")) {
            console.warn(
              `Base experiment ${args["base_experiment"]} not found.`
            );
            delete args["base_experiment"];
          } else {
            throw e;
          }
        }
      }
      return {
        project: {
          id: response.project.id,
          name: response.project.name,
          fullInfo: response.project
        },
        experiment: {
          id: response.experiment.id,
          name: response.experiment.name,
          fullInfo: response.experiment
        }
      };
    }
  );
  const ret = new Experiment(state, lazyMetadata, dataset);
  if (options.setCurrent ?? true) {
    state.currentExperiment = ret;
  }
  return ret;
}
function initExperiment(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either init(project, options) or init(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  return init(options);
}
function withExperiment(project, callback, options = {}) {
  console.warn(
    "withExperiment is deprecated and will be removed in a future version of braintrust. Simply create the experiment with `init`."
  );
  const experiment = init(project, options);
  return callback(experiment);
}
function withLogger(callback, options = {}) {
  console.warn(
    "withLogger is deprecated and will be removed in a future version of braintrust. Simply create the logger with `initLogger`."
  );
  const logger = initLogger(options);
  return callback(logger);
}
function initDataset(projectOrOptions, optionalOptions) {
  const options = (() => {
    if (typeof projectOrOptions === "string") {
      return { ...optionalOptions, project: projectOrOptions };
    } else {
      if (optionalOptions !== void 0) {
        throw new Error(
          "Cannot specify options struct as both parameters. Must call either initDataset(project, options) or initDataset(options)."
        );
      }
      return projectOrOptions;
    }
  })();
  const {
    project,
    dataset,
    description,
    version,
    appUrl,
    apiKey,
    orgName,
    fetch: fetch2,
    forceLogin,
    projectId,
    metadata,
    useOutput: legacy,
    state: stateArg
  } = options;
  const state = stateArg ?? _globalState;
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({
        orgName,
        apiKey,
        appUrl,
        fetch: fetch2,
        forceLogin
      });
      const args = {
        org_id: state.orgId,
        project_name: project,
        project_id: projectId,
        dataset_name: dataset,
        description,
        metadata
      };
      const response = await state.appConn().post_json("api/dataset/register", args);
      return {
        project: {
          id: response.project.id,
          name: response.project.name,
          fullInfo: response.project
        },
        dataset: {
          id: response.dataset.id,
          name: response.dataset.name,
          fullInfo: response.dataset
        }
      };
    }
  );
  return new Dataset(stateArg ?? _globalState, lazyMetadata, version, legacy);
}
function withDataset(project, callback, options = {}) {
  console.warn(
    "withDataset is deprecated and will be removed in a future version of braintrust. Simply create the dataset with `initDataset`."
  );
  const dataset = initDataset(project, options);
  return callback(dataset);
}
async function computeLoggerMetadata(state, {
  project_name,
  project_id
}) {
  await state.login({});
  const org_id = state.orgId;
  if (isEmpty(project_id)) {
    const response = await state.appConn().post_json("api/project/register", {
      project_name: project_name || GLOBAL_PROJECT,
      org_id
    });
    return {
      org_id,
      project: {
        id: response.project.id,
        name: response.project.name,
        fullInfo: response.project
      }
    };
  } else if (isEmpty(project_name)) {
    const response = await state.appConn().get_json("api/project", {
      id: project_id
    });
    return {
      org_id,
      project: {
        id: project_id,
        name: response.name,
        fullInfo: response.project
      }
    };
  } else {
    return {
      org_id,
      project: { id: project_id, name: project_name, fullInfo: {} }
    };
  }
}
function initLogger(options = {}) {
  const {
    projectName,
    projectId,
    asyncFlush,
    appUrl,
    apiKey,
    orgName,
    forceLogin,
    fetch: fetch2,
    state: stateArg
  } = options || {};
  const computeMetadataArgs = {
    project_name: projectName,
    project_id: projectId
  };
  const state = stateArg ?? _globalState;
  const lazyMetadata = new LazyValue(
    async () => {
      await state.login({
        orgName,
        apiKey,
        appUrl,
        forceLogin,
        fetch: fetch2
      });
      return computeLoggerMetadata(state, computeMetadataArgs);
    }
  );
  const ret = new Logger(state, lazyMetadata, {
    asyncFlush,
    computeMetadataArgs
  });
  if (options.setCurrent ?? true) {
    state.currentLogger = ret;
  }
  return ret;
}
async function loadPrompt({
  projectName,
  projectId,
  slug,
  version,
  defaults,
  noTrace = false,
  appUrl,
  apiKey,
  orgName,
  fetch: fetch2,
  forceLogin,
  state: stateArg
}) {
  if (isEmpty(projectName) && isEmpty(projectId)) {
    throw new Error("Must specify either projectName or projectId");
  }
  if (isEmpty(slug)) {
    throw new Error("Must specify slug");
  }
  const state = stateArg ?? _globalState;
  await state.login({
    orgName,
    apiKey,
    appUrl,
    fetch: fetch2,
    forceLogin
  });
  const args = {
    project_name: projectName,
    project_id: projectId,
    slug,
    version
  };
  const response = await state.apiConn().get_json("v1/prompt", args);
  if (!("objects" in response) || response.objects.length === 0) {
    throw new Error(
      `Prompt ${slug} not found in ${[projectName ?? projectId]}`
    );
  } else if (response.objects.length > 1) {
    throw new Error(
      `Multiple prompts found with slug ${slug} in project ${projectName ?? projectId}. This should never happen.`
    );
  }
  const metadata = promptSchema.parse(response["objects"][0]);
  return new Prompt(metadata, defaults || {}, noTrace);
}
async function login(options = {}) {
  const { forceLogin = false } = options || {};
  if (_globalState.loggedIn && !forceLogin) {
    let checkUpdatedParam2 = function(varname, arg, orig) {
      if (!isEmpty(arg) && !isEmpty(orig) && arg !== orig) {
        throw new Error(
          `Re-logging in with different ${varname} (${arg}) than original (${orig}). To force re-login, pass \`forceLogin: true\``
        );
      }
    };
    var checkUpdatedParam = checkUpdatedParam2;
    checkUpdatedParam2("appUrl", options.appUrl, _globalState.appUrl);
    checkUpdatedParam2(
      "apiKey",
      options.apiKey ? HTTPConnection.sanitize_token(options.apiKey) : void 0,
      _globalState.loginToken
    );
    checkUpdatedParam2("orgName", options.orgName, _globalState.orgName);
    return _globalState;
  }
  await _globalState.login(options);
  globalThis.__inherited_braintrust_state = _globalState;
  return _globalState;
}
async function loginToState(options = {}) {
  const {
    appUrl = isomorph_default.getEnv("BRAINTRUST_APP_URL") || "https://www.braintrust.dev",
    apiKey = isomorph_default.getEnv("BRAINTRUST_API_KEY"),
    orgName = isomorph_default.getEnv("BRAINTRUST_ORG_NAME"),
    fetch: fetch2 = globalThis.fetch
  } = options || {};
  const appPublicUrl = isomorph_default.getEnv("BRAINTRUST_APP_PUBLIC_URL") || appUrl;
  const state = new BraintrustState(options);
  state.resetLoginInfo();
  state.appUrl = appUrl;
  state.appPublicUrl = appPublicUrl;
  let conn = null;
  if (apiKey !== void 0) {
    const resp = await checkResponse(
      await fetch2(_urljoin(state.appUrl, `/api/apikey/login`), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`
        }
      })
    );
    const info = await resp.json();
    _check_org_info(state, info.org_info, orgName);
    conn = state.apiConn();
    conn.set_token(apiKey);
  } else {
    throw new Error(
      "Please specify an api key (e.g. by setting BRAINTRUST_API_KEY)."
    );
  }
  if (!conn) {
    throw new Error("Conn should be set at this point (a bug)");
  }
  conn.make_long_lived();
  state.appConn().set_token(apiKey);
  if (state.proxyUrl) {
    state.proxyConn().set_token(apiKey);
  }
  state.loginToken = conn.token;
  state.loggedIn = true;
  state.loginReplaceApiConn(conn);
  return state;
}
function log(event) {
  console.warn(
    "braintrust.log is deprecated and will be removed in a future version of braintrust. Use `experiment.log` instead."
  );
  const e = currentExperiment();
  if (!e) {
    throw new Error("Not initialized. Please call init() first");
  }
  return e.log(event);
}
async function summarize(options = {}) {
  console.warn(
    "braintrust.summarize is deprecated and will be removed in a future version of braintrust. Use `experiment.summarize` instead."
  );
  const e = currentExperiment();
  if (!e) {
    throw new Error("Not initialized. Please call init() first");
  }
  return await e.summarize(options);
}
function currentExperiment(options) {
  const state = options?.state ?? _globalState;
  return state.currentExperiment;
}
function currentLogger(options) {
  const state = options?.state ?? _globalState;
  return castLogger(state.currentLogger, options?.asyncFlush);
}
function currentSpan(options) {
  const state = options?.state ?? _globalState;
  return state.currentSpan.getStore() ?? NOOP_SPAN;
}
function getSpanParentObject(options) {
  const state = options?.state ?? _globalState;
  const parentSpan = currentSpan({ state });
  if (!Object.is(parentSpan, NOOP_SPAN)) {
    return parentSpan;
  }
  const experiment = currentExperiment();
  if (experiment) {
    return experiment;
  }
  const logger = currentLogger(options);
  if (logger) {
    return logger;
  }
  return NOOP_SPAN;
}
function logError(span, error) {
  let errorMessage = "<error>";
  let stackTrace = "";
  if (error instanceof Error) {
    errorMessage = error.message;
    stackTrace = error.stack || "";
  } else {
    errorMessage = String(error);
  }
  span.log({ error: `${errorMessage}

${stackTrace}` });
}
function traced(callback, args) {
  const { span, isSyncFlushLogger } = startSpanAndIsLogger(args);
  const ret = runCatchFinally(
    () => {
      if (args?.setCurrent ?? true) {
        return withCurrent(span, callback);
      } else {
        return callback(span);
      }
    },
    (e) => {
      logError(span, e);
      throw e;
    },
    () => span.end()
  );
  if (args?.asyncFlush) {
    return ret;
  } else {
    return (async () => {
      const awaitedRet = await ret;
      if (isSyncFlushLogger) {
        await span.flush();
      }
      return awaitedRet;
    })();
  }
}
function wrapTraced(fn, args) {
  const spanArgs = {
    name: fn.name,
    type: "function",
    ...args
  };
  const hasExplicitInput = args && args.event && "input" in args.event && args.event.input !== void 0;
  const hasExplicitOutput = args && args.event && args.event.output !== void 0;
  if (args?.asyncFlush) {
    return (...fnArgs) => traced((span) => {
      if (!hasExplicitInput) {
        span.log({ input: fnArgs });
      }
      const output = fn(...fnArgs);
      if (!hasExplicitOutput) {
        if (output instanceof Promise) {
          return (async () => {
            const result = await output;
            span.log({ output: result });
            return result;
          })();
        } else {
          span.log({ output });
        }
      }
      return output;
    }, spanArgs);
  } else {
    return (...fnArgs) => traced(async (span) => {
      if (!hasExplicitInput) {
        span.log({ input: fnArgs });
      }
      const outputResult = fn(...fnArgs);
      const output = await outputResult;
      if (!hasExplicitOutput) {
        span.log({ output });
      }
      return output;
    }, spanArgs);
  }
}
var traceable = wrapTraced;
function startSpan(args) {
  return startSpanAndIsLogger(args).span;
}
async function flush(options) {
  const state = options?.state ?? _globalState;
  return await state.bgLogger().flush();
}
function setFetch(fetch2) {
  _globalState.setFetch(fetch2);
}
function startSpanAndIsLogger(args) {
  const state = args?.state ?? _globalState;
  if (args?.parent) {
    const components = SpanComponentsV3.fromStr(args?.parent);
    const parentSpanIds = components.data.row_id ? {
      spanId: components.data.span_id,
      rootSpanId: components.data.root_span_id
    } : void 0;
    const span = new SpanImpl({
      state,
      ...args,
      parentObjectType: components.data.object_type,
      parentObjectId: new LazyValue(
        spanComponentsToObjectIdLambda(state, components)
      ),
      parentComputeObjectMetadataArgs: components.data.compute_object_metadata_args ?? void 0,
      parentSpanIds,
      propagatedEvent: args?.propagatedEvent ?? (components.data.propagated_event ?? void 0)
    });
    return {
      span,
      isSyncFlushLogger: components.data.object_type === SpanObjectTypeV3.PROJECT_LOGS && // Since there's no parent logger here, we're free to choose the async flush
      // behavior, and therefore propagate along whatever we get from the arguments
      !args?.asyncFlush
    };
  } else {
    const parentObject = getSpanParentObject({
      asyncFlush: args?.asyncFlush
    });
    const span = parentObject.startSpan(args);
    return {
      span,
      isSyncFlushLogger: parentObject.kind === "logger" && !parentObject.asyncFlush
    };
  }
}
function withCurrent(span, callback, state = _globalState) {
  return state.currentSpan.run(span, () => callback(span));
}
function _check_org_info(state, org_info, org_name) {
  if (org_info.length === 0) {
    throw new Error("This user is not part of any organizations.");
  }
  for (const org of org_info) {
    if (org_name === void 0 || org.name === org_name) {
      state.orgId = org.id;
      state.orgName = org.name;
      state.apiUrl = isomorph_default.getEnv("BRAINTRUST_API_URL") ?? org.api_url;
      state.proxyUrl = isomorph_default.getEnv("BRAINTRUST_PROXY_URL") ?? org.proxy_url;
      state.gitMetadataSettings = org.git_metadata || void 0;
      break;
    }
  }
  if (state.orgId === void 0) {
    throw new Error(
      `Organization ${org_name} not found. Must be one of ${org_info.map((x) => x.name).join(", ")}`
    );
  }
}
function validateTags(tags) {
  const seen = /* @__PURE__ */ new Set();
  for (const tag of tags) {
    if (typeof tag !== "string") {
      throw new Error("tags must be strings");
    }
    if (seen.has(tag)) {
      throw new Error(`duplicate tag: ${tag}`);
    }
  }
}
function validateAndSanitizeExperimentLogPartialArgs(event) {
  if (event.scores) {
    if (Array.isArray(event.scores)) {
      throw new Error("scores must be an object, not an array");
    }
    for (let [name, score] of Object.entries(event.scores)) {
      if (typeof name !== "string") {
        throw new Error("score names must be strings");
      }
      if (score === null || score === void 0) {
        continue;
      }
      if (typeof score === "boolean") {
        score = score ? 1 : 0;
        event.scores[name] = score;
      }
      if (typeof score !== "number") {
        throw new Error("score values must be numbers");
      }
      if (score < 0 || score > 1) {
        throw new Error("score values must be between 0 and 1");
      }
    }
  }
  if (event.metadata) {
    for (const key of Object.keys(event.metadata)) {
      if (typeof key !== "string") {
        throw new Error("metadata keys must be strings");
      }
    }
  }
  if (event.metrics) {
    for (const [key, value] of Object.entries(event.metrics)) {
      if (typeof key !== "string") {
        throw new Error("metric keys must be strings");
      }
      if (value !== void 0 && typeof value !== "number") {
        throw new Error("metric values must be numbers");
      }
    }
  }
  if ("input" in event && event.input && "inputs" in event && event.inputs) {
    throw new Error(
      "Only one of input or inputs (deprecated) can be specified. Prefer input."
    );
  }
  if ("tags" in event && event.tags) {
    validateTags(event.tags);
  }
  if ("inputs" in event) {
    const { inputs, ...rest } = event;
    return { input: inputs, ...rest };
  } else {
    return { ...event };
  }
}
function deepCopyEvent(event) {
  const attachments = [];
  const IDENTIFIER = "_bt_internal_saved_attachment";
  const savedAttachmentSchema = z2.strictObject({ [IDENTIFIER]: z2.number() });
  const serialized = JSON.stringify(event, (_k, v) => {
    if (v instanceof SpanImpl || v instanceof NoopSpan) {
      return `<span>`;
    } else if (v instanceof Experiment) {
      return `<experiment>`;
    } else if (v instanceof Dataset) {
      return `<dataset>`;
    } else if (v instanceof Logger) {
      return `<logger>`;
    } else if (v instanceof Attachment) {
      const idx = attachments.push(v);
      return { [IDENTIFIER]: idx - 1 };
    }
    return v;
  });
  const x = JSON.parse(serialized, (_k, v) => {
    const parsedAttachment = savedAttachmentSchema.safeParse(v);
    if (parsedAttachment.success) {
      return attachments[parsedAttachment.data[IDENTIFIER]];
    }
    return v;
  });
  return x;
}
function extractAttachments(event, attachments) {
  for (const [key, value] of Object.entries(event)) {
    if (value instanceof Attachment) {
      attachments.push(value);
      event[key] = value.reference;
      continue;
    }
    if (!(value instanceof Object)) {
      continue;
    }
    extractAttachments(value, attachments);
  }
}
function validateAndSanitizeExperimentLogFullArgs(event, hasDataset) {
  if ("input" in event && !isEmpty(event.input) && "inputs" in event && !isEmpty(event.inputs) || !("input" in event) && !("inputs" in event)) {
    throw new Error(
      "Exactly one of input or inputs (deprecated) must be specified. Prefer input."
    );
  }
  if (isEmpty(event.output)) {
    throw new Error("output must be specified");
  }
  if (isEmpty(event.scores)) {
    throw new Error("scores must be specified");
  }
  if (hasDataset && event.datasetRecordId === void 0) {
    throw new Error("datasetRecordId must be specified when using a dataset");
  } else if (!hasDataset && event.datasetRecordId !== void 0) {
    throw new Error(
      "datasetRecordId cannot be specified when not using a dataset"
    );
  }
  return event;
}
var ObjectFetcher = class {
  constructor(objectType, pinnedVersion, mutateRecord) {
    this.objectType = objectType;
    this.pinnedVersion = pinnedVersion;
    this.mutateRecord = mutateRecord;
  }
  _fetchedData = void 0;
  get id() {
    throw new Error("ObjectFetcher subclasses must have an 'id' attribute");
  }
  async getState() {
    throw new Error("ObjectFetcher subclasses must have a 'getState' method");
  }
  async *fetch() {
    const records = await this.fetchedData();
    for (const record of records) {
      yield record;
    }
  }
  [Symbol.asyncIterator]() {
    return this.fetch();
  }
  async fetchedData() {
    if (this._fetchedData === void 0) {
      const state = await this.getState();
      const resp = await state.apiConn().get(
        `v1/${this.objectType}/${await this.id}/fetch`,
        {
          version: this.pinnedVersion
        },
        { headers: { "Accept-Encoding": "gzip" } }
      );
      const data = (await resp.json()).events;
      this._fetchedData = this.mutateRecord ? data?.map(this.mutateRecord) : data;
    }
    return this._fetchedData || [];
  }
  clearCache() {
    this._fetchedData = void 0;
  }
  async version() {
    if (this.pinnedVersion !== void 0) {
      return this.pinnedVersion;
    } else {
      const fetchedData = await this.fetchedData();
      let maxVersion = void 0;
      for (const record of fetchedData) {
        const xactId = String(record[TRANSACTION_ID_FIELD] ?? "0");
        if (maxVersion === void 0 || xactId > maxVersion) {
          maxVersion = xactId;
        }
      }
      return maxVersion;
    }
  }
};
var Experiment = class extends ObjectFetcher {
  lazyMetadata;
  dataset;
  lastStartTime;
  lazyId;
  calledStartSpan;
  state;
  // For type identification.
  kind = "experiment";
  constructor(state, lazyMetadata, dataset) {
    super("experiment", void 0);
    this.lazyMetadata = lazyMetadata;
    this.dataset = dataset;
    this.lastStartTime = getCurrentUnixTimestamp();
    this.lazyId = new LazyValue(async () => await this.id);
    this.calledStartSpan = false;
    this.state = state;
  }
  get id() {
    return (async () => {
      return (await this.lazyMetadata.get()).experiment.id;
    })();
  }
  get name() {
    return (async () => {
      return (await this.lazyMetadata.get()).experiment.name;
    })();
  }
  get project() {
    return (async () => {
      return (await this.lazyMetadata.get()).project;
    })();
  }
  parentObjectType() {
    return SpanObjectTypeV3.EXPERIMENT;
  }
  async getState() {
    await this.lazyMetadata.get();
    return this.state;
  }
  /**
   * Log a single event to the experiment. The event will be batched and uploaded behind the scenes.
   *
   * @param event The event to log.
   * @param event.input: The arguments that uniquely define a test case (an arbitrary, JSON serializable object). Later on, Braintrust will use the `input` to know whether two test cases are the same between experiments, so they should not contain experiment-specific state. A simple rule of thumb is that if you run the same experiment twice, the `input` should be identical.
   * @param event.output: The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question.
   * @param event.expected: (Optional) The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate your experiments while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models.
   * @param event.error: (Optional) The error that occurred, if any. If you use tracing to run an experiment, errors are automatically logged when your code throws an exception.
   * @param event.scores: A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare experiments.
   * @param event.metadata: (Optional) a dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings.
   * @param event.metrics: (Optional) a dictionary of metrics to log. The following keys are populated automatically: "start", "end".
   * @param event.id: (Optional) a unique identifier for the event. If you don't provide one, BrainTrust will generate one for you.
   * @param event.dataset_record_id: (Optional) the id of the dataset record that this event is associated with. This field is required if and only if the experiment is associated with a dataset.
   * @param options Additional logging options
   * @param options.allowConcurrentWithSpans in rare cases where you need to log at the top level separately from spans on the experiment elsewhere, set this to true.
   * @returns The `id` of the logged event.
   */
  log(event, options) {
    if (this.calledStartSpan && !options?.allowConcurrentWithSpans) {
      throw new Error(
        "Cannot run toplevel `log` method while using spans. To log to the span, call `experiment.traced` and then log with `span.log`"
      );
    }
    event = validateAndSanitizeExperimentLogFullArgs(event, !!this.dataset);
    const span = this.startSpanImpl({ startTime: this.lastStartTime, event });
    this.lastStartTime = span.end();
    return span.id;
  }
  /**
   * Create a new toplevel span underneath the experiment. The name defaults to "root".
   *
   * See {@link Span.traced} for full details.
   */
  traced(callback, args) {
    const { setCurrent, ...argsRest } = args ?? {};
    const span = this.startSpan(argsRest);
    const ret = runCatchFinally(
      () => {
        if (setCurrent ?? true) {
          return withCurrent(span, callback);
        } else {
          return callback(span);
        }
      },
      (e) => {
        logError(span, e);
        throw e;
      },
      () => span.end()
    );
    return ret;
  }
  /**
   * Lower-level alternative to `traced`. This allows you to start a span yourself, and can be useful in situations
   * where you cannot use callbacks. However, spans started with `startSpan` will not be marked as the "current span",
   * so `currentSpan()` and `traced()` will be no-ops. If you want to mark a span as current, use `traced` instead.
   *
   * See {@link traced} for full details.
   */
  startSpan(args) {
    this.calledStartSpan = true;
    return this.startSpanImpl(args);
  }
  startSpanImpl(args) {
    return new SpanImpl({
      state: this.state,
      ...args,
      ...startSpanParentArgs({
        state: this.state,
        parent: args?.parent,
        parentObjectType: this.parentObjectType(),
        parentObjectId: this.lazyId,
        parentComputeObjectMetadataArgs: void 0,
        parentSpanIds: void 0,
        propagatedEvent: args?.propagatedEvent
      }),
      defaultRootType: SpanTypeAttribute.EVAL
    });
  }
  async fetchBaseExperiment() {
    const state = await this.getState();
    const conn = state.appConn();
    try {
      const resp = await conn.post("/api/base_experiment/get_id", {
        id: await this.id
      });
      const base = await resp.json();
      return {
        id: base["base_exp_id"],
        name: base["base_exp_name"]
      };
    } catch (e) {
      if (e instanceof FailedHTTPResponse && e.status === 400) {
        return null;
      } else {
        throw e;
      }
    }
  }
  /**
   * Summarize the experiment, including the scores (compared to the closest reference experiment) and metadata.
   *
   * @param options Options for summarizing the experiment.
   * @param options.summarizeScores Whether to summarize the scores. If False, only the metadata will be returned.
   * @param options.comparisonExperimentId The experiment to compare against. If None, the most recent experiment on the origin's main branch will be used.
   * @returns A summary of the experiment, including the scores (compared to the closest reference experiment) and metadata.
   */
  async summarize(options = {}) {
    let { summarizeScores = true, comparisonExperimentId = void 0 } = options || {};
    await this.flush();
    const state = await this.getState();
    const projectUrl = `${state.appPublicUrl}/app/${encodeURIComponent(
      state.orgName
    )}/p/${encodeURIComponent((await this.project).name)}`;
    const experimentUrl = `${projectUrl}/experiments/${encodeURIComponent(
      await this.name
    )}`;
    let scores = void 0;
    let metrics = void 0;
    let comparisonExperimentName = void 0;
    if (summarizeScores) {
      if (comparisonExperimentId === void 0) {
        const baseExperiment = await this.fetchBaseExperiment();
        if (baseExperiment !== null) {
          comparisonExperimentId = baseExperiment.id;
          comparisonExperimentName = baseExperiment.name;
        }
      }
      const results = await state.apiConn().get_json(
        "/experiment-comparison2",
        {
          experiment_id: await this.id,
          base_experiment_id: comparisonExperimentId
        },
        3
      );
      scores = results["scores"];
      metrics = results["metrics"];
    }
    return {
      projectName: (await this.project).name,
      experimentName: await this.name,
      projectId: (await this.project).id,
      experimentId: await this.id,
      projectUrl,
      experimentUrl,
      comparisonExperimentName,
      scores: scores ?? {},
      metrics
    };
  }
  /**
   * Log feedback to an event in the experiment. Feedback is used to save feedback scores, set an expected value, or add a comment.
   *
   * @param event
   * @param event.id The id of the event to log feedback for. This is the `id` returned by `log` or accessible as the `id` field of a span.
   * @param event.scores (Optional) a dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the event.
   * @param event.expected (Optional) the ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not.
   * @param event.comment (Optional) an optional comment string to log about the event.
   * @param event.metadata (Optional) a dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI. Note, this metadata does not correspond to the main event itself, but rather the audit log attached to the event.
   * @param event.source (Optional) the source of the feedback. Must be one of "external" (default), "app", or "api".
   */
  logFeedback(event) {
    logFeedbackImpl(this.state, this.parentObjectType(), this.lazyId, event);
  }
  /**
   * Update a span in the experiment using its id. It is important that you only update a span once the original span has been fully written and flushed,
   * since otherwise updates to the span may conflict with the original span.
   *
   * @param event The event data to update the span with. Must include `id`. See {@link Experiment.log} for a full list of valid fields.
   */
  updateSpan(event) {
    const { id, ...eventRest } = event;
    if (!id) {
      throw new Error("Span id is required to update a span");
    }
    updateSpanImpl({
      state: this.state,
      parentObjectType: this.parentObjectType(),
      parentObjectId: this.lazyId,
      id,
      event: eventRest
    });
  }
  /**
   * Return a serialized representation of the experiment that can be used to start subspans in other places.
   *
   * See {@link Span.startSpan} for more details.
   */
  async export() {
    return new SpanComponentsV3({
      object_type: this.parentObjectType(),
      object_id: await this.id
    }).toStr();
  }
  /**
   * Flush any pending rows to the server.
   */
  async flush() {
    return await this.state.bgLogger().flush();
  }
  /**
   * @deprecated This function is deprecated. You can simply remove it from your code.
   */
  async close() {
    console.warn(
      "close is deprecated and will be removed in a future version of braintrust. It is now a no-op and can be removed"
    );
    return this.id;
  }
};
var ReadonlyExperiment = class extends ObjectFetcher {
  constructor(state, lazyMetadata) {
    super("experiment", void 0);
    this.state = state;
    this.lazyMetadata = lazyMetadata;
  }
  get id() {
    return (async () => {
      return (await this.lazyMetadata.get()).experiment.id;
    })();
  }
  get name() {
    return (async () => {
      return (await this.lazyMetadata.get()).experiment.name;
    })();
  }
  async getState() {
    await this.lazyMetadata.get();
    return this.state;
  }
  async *asDataset() {
    const records = this.fetch();
    for await (const record of records) {
      if (record.root_span_id !== record.span_id) {
        continue;
      }
      const { output, expected: expectedRecord } = record;
      const expected = expectedRecord ?? output;
      if (isEmpty(expected)) {
        yield {
          input: record.input,
          tags: record.tags
        };
      } else {
        yield {
          input: record.input,
          expected,
          tags: record.tags
        };
      }
    }
  }
};
var executionCounter = 0;
function newId() {
  return uuidv4();
}
var SpanImpl = class _SpanImpl {
  state;
  isMerge;
  loggedEndTime;
  propagatedEvent;
  // For internal use only.
  parentObjectType;
  parentObjectId;
  parentComputeObjectMetadataArgs;
  _id;
  spanId;
  rootSpanId;
  spanParents;
  kind = "span";
  constructor(args) {
    this.state = args.state;
    const spanAttributes = args.spanAttributes ?? {};
    const rawEvent = args.event ?? {};
    const type = args.type ?? (args.parentSpanIds ? void 0 : args.defaultRootType);
    this.loggedEndTime = void 0;
    this.parentObjectType = args.parentObjectType;
    this.parentObjectId = args.parentObjectId;
    this.parentComputeObjectMetadataArgs = args.parentComputeObjectMetadataArgs;
    this.propagatedEvent = args.propagatedEvent;
    if (this.propagatedEvent) {
      mergeDicts(rawEvent, this.propagatedEvent);
    }
    const { id: eventId, ...event } = rawEvent;
    const callerLocation = isomorph_default.getCallerLocation();
    const name = (() => {
      if (args.name)
        return args.name;
      if (!args.parentSpanIds)
        return "root";
      if (callerLocation) {
        const pathComponents = callerLocation.caller_filename.split("/");
        const filename = pathComponents[pathComponents.length - 1];
        return [callerLocation.caller_functionname].concat(
          filename ? [`${filename}:${callerLocation.caller_lineno}`] : []
        ).join(":");
      }
      return "subspan";
    })();
    const internalData = {
      metrics: {
        start: args.startTime ?? getCurrentUnixTimestamp()
      },
      context: { ...callerLocation },
      span_attributes: {
        name,
        type,
        ...spanAttributes,
        exec_counter: executionCounter++
      },
      created: (/* @__PURE__ */ new Date()).toISOString()
    };
    this._id = eventId ?? uuidv4();
    this.spanId = uuidv4();
    if (args.parentSpanIds) {
      this.rootSpanId = args.parentSpanIds.rootSpanId;
      this.spanParents = [args.parentSpanIds.spanId];
    } else {
      this.rootSpanId = this.spanId;
      this.spanParents = void 0;
    }
    this.isMerge = false;
    this.logInternal({ event, internalData });
    this.isMerge = true;
  }
  get id() {
    return this._id;
  }
  setAttributes(args) {
    this.logInternal({ internalData: { span_attributes: args } });
  }
  log(event) {
    this.logInternal({ event });
  }
  logInternal({
    event,
    internalData
  }) {
    const [serializableInternalData, lazyInternalData] = splitLoggingData({
      event,
      internalData
    });
    const partialRecord = deepCopyEvent({
      id: this.id,
      span_id: this.spanId,
      root_span_id: this.rootSpanId,
      span_parents: this.spanParents,
      ...serializableInternalData,
      [IS_MERGE_FIELD]: this.isMerge
    });
    if (partialRecord.metrics?.end) {
      this.loggedEndTime = partialRecord.metrics?.end;
    }
    if ((partialRecord.tags ?? []).length > 0 && this.spanParents?.length) {
      throw new Error("Tags can only be logged to the root span");
    }
    const computeRecord = async () => ({
      ...partialRecord,
      ...Object.fromEntries(
        await Promise.all(
          Object.entries(lazyInternalData).map(async ([key, value]) => [
            key,
            await value.get()
          ])
        )
      ),
      ...new SpanComponentsV3({
        object_type: this.parentObjectType,
        object_id: await this.parentObjectId.get()
      }).objectIdFields()
    });
    this.state.bgLogger().log([new LazyValue(computeRecord)]);
  }
  logFeedback(event) {
    logFeedbackImpl(this.state, this.parentObjectType, this.parentObjectId, {
      ...event,
      id: this.id
    });
  }
  traced(callback, args) {
    const { setCurrent, ...argsRest } = args ?? {};
    const span = this.startSpan(argsRest);
    return runCatchFinally(
      () => {
        if (setCurrent ?? true) {
          return withCurrent(span, callback);
        } else {
          return callback(span);
        }
      },
      (e) => {
        logError(span, e);
        throw e;
      },
      () => span.end()
    );
  }
  startSpan(args) {
    const parentSpanIds = args?.parent ? void 0 : { spanId: this.spanId, rootSpanId: this.rootSpanId };
    return new _SpanImpl({
      state: this.state,
      ...args,
      ...startSpanParentArgs({
        state: this.state,
        parent: args?.parent,
        parentObjectType: this.parentObjectType,
        parentObjectId: this.parentObjectId,
        parentComputeObjectMetadataArgs: this.parentComputeObjectMetadataArgs,
        parentSpanIds,
        propagatedEvent: args?.propagatedEvent ?? this.propagatedEvent
      })
    });
  }
  end(args) {
    let endTime;
    let internalData = {};
    if (!this.loggedEndTime) {
      endTime = args?.endTime ?? getCurrentUnixTimestamp();
      internalData = { metrics: { end: endTime } };
    } else {
      endTime = this.loggedEndTime;
    }
    this.logInternal({ internalData });
    return endTime;
  }
  async export() {
    return new SpanComponentsV3({
      object_type: this.parentObjectType,
      ...this.parentComputeObjectMetadataArgs && !this.parentObjectId.hasComputed ? { compute_object_metadata_args: this.parentComputeObjectMetadataArgs } : { object_id: await this.parentObjectId.get() },
      row_id: this.id,
      span_id: this.spanId,
      root_span_id: this.rootSpanId,
      propagated_event: this.propagatedEvent
    }).toStr();
  }
  async permalink() {
    return await permalink(await this.export(), {
      state: this.state
    });
  }
  async flush() {
    return await this.state.bgLogger().flush();
  }
  close(args) {
    return this.end(args);
  }
};
function splitLoggingData({
  event,
  internalData
}) {
  const sanitized = validateAndSanitizeExperimentLogPartialArgs(event ?? {});
  const sanitizedAndInternalData = {};
  mergeDicts(sanitizedAndInternalData, internalData || {});
  mergeDicts(sanitizedAndInternalData, sanitized);
  const serializableInternalData = {};
  const lazyInternalData = {};
  for (const [key, value] of Object.entries(sanitizedAndInternalData)) {
    if (value instanceof BraintrustStream) {
      const streamCopy = value.copy();
      lazyInternalData[key] = new LazyValue(async () => {
        return await new Promise((resolve, reject) => {
          streamCopy.toReadableStream().pipeThrough(createFinalValuePassThroughStream(resolve, reject)).pipeTo(devNullWritableStream());
        });
      });
    } else if (value instanceof ReadableStream) {
      lazyInternalData[key] = new LazyValue(async () => {
        return await new Promise((resolve, reject) => {
          value.pipeThrough(createFinalValuePassThroughStream(resolve, reject)).pipeTo(devNullWritableStream());
        });
      });
    } else {
      serializableInternalData[key] = value;
    }
  }
  return [serializableInternalData, lazyInternalData];
}
var Dataset = class extends ObjectFetcher {
  constructor(state, lazyMetadata, pinnedVersion, legacy) {
    const isLegacyDataset = legacy ?? DEFAULT_IS_LEGACY_DATASET;
    if (isLegacyDataset) {
      console.warn(
        `Records will be fetched from this dataset in the legacy format, with the "expected" field renamed to "output". Please update your code to use "expected", and use \`braintrust.initDataset()\` with \`{ useOutput: false }\`, which will become the default in a future version of Braintrust.`
      );
    }
    super(
      "dataset",
      pinnedVersion,
      (r) => ensureDatasetRecord(r, isLegacyDataset)
    );
    this.state = state;
    this.lazyMetadata = lazyMetadata;
  }
  lazyMetadata;
  get id() {
    return (async () => {
      return (await this.lazyMetadata.get()).dataset.id;
    })();
  }
  get name() {
    return (async () => {
      return (await this.lazyMetadata.get()).dataset.name;
    })();
  }
  get project() {
    return (async () => {
      return (await this.lazyMetadata.get()).project;
    })();
  }
  async getState() {
    await this.lazyMetadata.get();
    return this.state;
  }
  validateEvent({
    metadata,
    expected,
    output,
    tags
  }) {
    if (metadata !== void 0) {
      for (const key of Object.keys(metadata)) {
        if (typeof key !== "string") {
          throw new Error("metadata keys must be strings");
        }
      }
    }
    if (expected !== void 0 && output !== void 0) {
      throw new Error(
        "Only one of expected or output (deprecated) can be specified. Prefer expected."
      );
    }
    if (tags) {
      validateTags(tags);
    }
  }
  createArgs({
    id,
    input,
    expected,
    metadata,
    tags,
    output,
    isMerge
  }) {
    return new LazyValue(async () => {
      const dataset_id = await this.id;
      const expectedValue = expected === void 0 ? output : expected;
      const args = {
        id,
        input,
        expected: expectedValue,
        tags,
        dataset_id,
        created: !isMerge ? (/* @__PURE__ */ new Date()).toISOString() : void 0,
        //if we're merging/updating an event we will not add this ts
        metadata,
        ...!!isMerge ? {
          [IS_MERGE_FIELD]: true
        } : {}
      };
      return args;
    });
  }
  /**
   * Insert a single record to the dataset. The record will be batched and uploaded behind the scenes. If you pass in an `id`,
   * and a record with that `id` already exists, it will be overwritten (upsert).
   *
   * @param event The event to log.
   * @param event.input The argument that uniquely define an input case (an arbitrary, JSON serializable object).
   * @param event.expected The output of your application, including post-processing (an arbitrary, JSON serializable object).
   * @param event.tags (Optional) a list of strings that you can use to filter and group records later.
   * @param event.metadata (Optional) a dictionary with additional data about the test example, model outputs, or just
   * about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the
   * `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any
   * JSON-serializable type, but its keys must be strings.
   * @param event.id (Optional) a unique identifier for the event. If you don't provide one, Braintrust will generate one for you.
   * @param event.output: (Deprecated) The output of your application. Use `expected` instead.
   * @returns The `id` of the logged record.
   */
  insert({
    input,
    expected,
    metadata,
    tags,
    id,
    output
  }) {
    this.validateEvent({ metadata, expected, output, tags });
    const rowId = id || uuidv4();
    const args = this.createArgs(
      deepCopyEvent({
        id: rowId,
        input,
        expected,
        metadata,
        tags,
        output,
        isMerge: false
      })
    );
    this.state.bgLogger().log([args]);
    return rowId;
  }
  /**
   * Update fields of a single record in the dataset. The updated fields will be batched and uploaded behind the scenes.
   * You must pass in an `id` of the record to update. Only the fields provided will be updated; other fields will remain unchanged.
   *
   * @param event The fields to update in the record.
   * @param event.id The unique identifier of the record to update.
   * @param event.input (Optional) The new input value for the record (an arbitrary, JSON serializable object).
   * @param event.expected (Optional) The new expected output value for the record (an arbitrary, JSON serializable object).
   * @param event.tags (Optional) A list of strings to update the tags of the record.
   * @param event.metadata (Optional) A dictionary to update the metadata of the record. The values in `metadata` can be any
   * JSON-serializable type, but its keys must be strings.
   * @returns The `id` of the updated record.
   */
  update({
    input,
    expected,
    metadata,
    tags,
    id
  }) {
    this.validateEvent({ metadata, expected, tags });
    const args = this.createArgs(
      deepCopyEvent({
        id,
        input,
        expected,
        metadata,
        tags,
        isMerge: true
      })
    );
    this.state.bgLogger().log([args]);
    return id;
  }
  delete(id) {
    const args = new LazyValue(async () => ({
      id,
      dataset_id: await this.id,
      created: (/* @__PURE__ */ new Date()).toISOString(),
      _object_delete: true
    }));
    this.state.bgLogger().log([args]);
    return id;
  }
  /**
   * Summarize the dataset, including high level metrics about its size and other metadata.
   * @param summarizeData Whether to summarize the data. If false, only the metadata will be returned.
   * @returns `DatasetSummary`
   * @returns A summary of the dataset.
   */
  async summarize(options = {}) {
    const { summarizeData = true } = options || {};
    await this.flush();
    const state = await this.getState();
    const projectUrl = `${state.appPublicUrl}/app/${encodeURIComponent(
      state.orgName
    )}/p/${encodeURIComponent((await this.project).name)}`;
    const datasetUrl = `${projectUrl}/datasets/${encodeURIComponent(
      await this.name
    )}`;
    let dataSummary = void 0;
    if (summarizeData) {
      dataSummary = await state.apiConn().get_json(
        "dataset-summary",
        {
          dataset_id: await this.id
        },
        3
      );
    }
    return {
      projectName: (await this.project).name,
      datasetName: await this.name,
      projectUrl,
      datasetUrl,
      dataSummary
    };
  }
  /**
   * Flush any pending rows to the server.
   */
  async flush() {
    return await this.state.bgLogger().flush();
  }
  /**
   * @deprecated This function is deprecated. You can simply remove it from your code.
   */
  async close() {
    console.warn(
      "close is deprecated and will be removed in a future version of braintrust. It is now a no-op and can be removed"
    );
    return this.id;
  }
};
function renderMessage(render, message) {
  return {
    ...message,
    ..."content" in message ? {
      content: isEmpty(message.content) ? void 0 : typeof message.content === "string" ? render(message.content) : message.content.map((c) => {
        switch (c.type) {
          case "text":
            return { ...c, text: render(c.text) };
          case "image_url":
            return {
              ...c,
              image_url: {
                ...c.image_url,
                url: render(c.image_url.url)
              }
            };
          default:
            const _exhaustiveCheck = c;
            return _exhaustiveCheck;
        }
      })
    } : {}
  };
}
var Prompt = class {
  constructor(metadata, defaults, noTrace) {
    this.metadata = metadata;
    this.defaults = defaults;
    this.noTrace = noTrace;
  }
  parsedPromptData;
  hasParsedPromptData = false;
  get id() {
    return this.metadata.id;
  }
  get projectId() {
    return this.metadata.project_id;
  }
  get name() {
    return "name" in this.metadata ? this.metadata.name : `Playground function ${this.metadata.id}`;
  }
  get slug() {
    return "slug" in this.metadata ? this.metadata.slug : this.metadata.id;
  }
  get prompt() {
    return this.getParsedPromptData()?.prompt;
  }
  get version() {
    return this.metadata[TRANSACTION_ID_FIELD];
  }
  get options() {
    return this.getParsedPromptData()?.options || {};
  }
  /**
   * Build the prompt with the given formatting options. The args you pass in will
   * be forwarded to the mustache template that defines the prompt and rendered with
   * the `mustache-js` library.
   *
   * @param buildArgs Args to forward along to the prompt template.
   */
  build(buildArgs, options = {}) {
    return this.runBuild(buildArgs, {
      flavor: options.flavor ?? "chat",
      messages: options.messages
    });
  }
  runBuild(buildArgs, options) {
    const { flavor } = options;
    const params = {
      ...this.defaults,
      ...Object.fromEntries(
        Object.entries(this.options.params || {}).filter(
          ([k, _v]) => !BRAINTRUST_PARAMS.includes(k)
        )
      ),
      ...!isEmpty(this.options.model) ? {
        model: this.options.model
      } : {}
    };
    if (!("model" in params) || isEmpty(params.model)) {
      throw new Error(
        "No model specified. Either specify it in the prompt or as a default"
      );
    }
    const spanInfo = this.noTrace ? {} : {
      span_info: {
        metadata: {
          prompt: this.id ? {
            variables: buildArgs,
            id: this.id,
            project_id: this.projectId,
            version: this.version,
            ..."prompt_session_id" in this.metadata ? { prompt_session_id: this.metadata.prompt_session_id } : {}
          } : void 0
        }
      }
    };
    const prompt = this.prompt;
    if (!prompt) {
      throw new Error("Empty prompt");
    }
    const dictArgParsed = z2.record(z2.unknown()).safeParse(buildArgs);
    const variables = {
      input: buildArgs,
      ...dictArgParsed.success ? dictArgParsed.data : {}
    };
    if (flavor === "chat") {
      if (prompt.type !== "chat") {
        throw new Error(
          "Prompt is a completion prompt. Use buildCompletion() instead"
        );
      }
      const render = (template) => Mustache.render(template, variables, void 0, {
        escape: (v) => typeof v === "string" ? v : JSON.stringify(v)
      });
      const messages = [
        ...(prompt.messages || []).map((m) => renderMessage(render, m)),
        ...options.messages ?? []
      ];
      return {
        ...params,
        ...spanInfo,
        messages,
        ...prompt.tools?.trim() ? {
          tools: toolsSchema.parse(
            JSON.parse(Mustache.render(prompt.tools, variables))
          )
        } : void 0
      };
    } else if (flavor === "completion") {
      if (prompt.type !== "completion") {
        throw new Error(`Prompt is a chat prompt. Use flavor: 'chat' instead`);
      }
      if (options.messages) {
        throw new Error(
          "extra messages are not supported for completion prompts"
        );
      }
      return {
        ...params,
        ...spanInfo,
        prompt: Mustache.render(prompt.content, variables)
      };
    } else {
      throw new Error("never!");
    }
  }
  getParsedPromptData() {
    if (!this.hasParsedPromptData) {
      this.parsedPromptData = promptDataSchema.parse(this.metadata.prompt_data);
      this.hasParsedPromptData = true;
    }
    return this.parsedPromptData;
  }
};
var _exportsForTestingOnly = { extractAttachments, deepCopyEvent };

// src/browser-config.ts
var browserConfigured = false;
function configureBrowser() {
  if (browserConfigured) {
    return;
  }
  try {
    if (typeof AsyncLocalStorage !== "undefined") {
      isomorph_default.newAsyncLocalStorage = () => new AsyncLocalStorage();
    }
  } catch {
  }
  isomorph_default.getEnv = (name) => {
    if (typeof process === "undefined" || typeof process.env === "undefined") {
      return void 0;
    }
    return process.env[name];
  };
  _internalSetInitialState();
  browserConfigured = true;
}

// src/exports-browser.ts
var exports_browser_exports = {};
__export(exports_browser_exports, {
  Attachment: () => Attachment,
  BraintrustState: () => BraintrustState,
  BraintrustStream: () => BraintrustStream,
  Dataset: () => Dataset,
  Experiment: () => Experiment,
  FailedHTTPResponse: () => FailedHTTPResponse,
  LEGACY_CACHED_HEADER: () => LEGACY_CACHED_HEADER,
  Logger: () => Logger,
  NOOP_SPAN: () => NOOP_SPAN,
  NoopSpan: () => NoopSpan,
  Prompt: () => Prompt,
  ReadonlyExperiment: () => ReadonlyExperiment,
  SpanImpl: () => SpanImpl,
  X_CACHED_HEADER: () => X_CACHED_HEADER,
  _exportsForTestingOnly: () => _exportsForTestingOnly,
  _internalGetGlobalState: () => _internalGetGlobalState,
  _internalSetInitialState: () => _internalSetInitialState,
  braintrustStreamChunkSchema: () => braintrustStreamChunkSchema,
  createFinalValuePassThroughStream: () => createFinalValuePassThroughStream,
  currentExperiment: () => currentExperiment,
  currentLogger: () => currentLogger,
  currentSpan: () => currentSpan,
  devNullWritableStream: () => devNullWritableStream,
  flush: () => flush,
  getSpanParentObject: () => getSpanParentObject,
  init: () => init,
  initDataset: () => initDataset,
  initExperiment: () => initExperiment,
  initLogger: () => initLogger,
  invoke: () => invoke,
  loadPrompt: () => loadPrompt,
  log: () => log,
  logError: () => logError,
  login: () => login,
  loginToState: () => loginToState,
  newId: () => newId,
  parseCachedHeader: () => parseCachedHeader,
  permalink: () => permalink,
  renderMessage: () => renderMessage,
  setFetch: () => setFetch,
  spanComponentsToObjectId: () => spanComponentsToObjectId,
  startSpan: () => startSpan,
  summarize: () => summarize,
  traceable: () => traceable,
  traced: () => traced,
  updateSpan: () => updateSpan,
  withCurrent: () => withCurrent,
  withDataset: () => withDataset,
  withExperiment: () => withExperiment,
  withLogger: () => withLogger,
  wrapOpenAI: () => wrapOpenAI,
  wrapOpenAIv4: () => wrapOpenAIv4,
  wrapTraced: () => wrapTraced
});

// src/functions/invoke.ts
import {
  functionIdSchema
} from "@braintrust/core/typespecs";
async function invoke(args) {
  const {
    orgName,
    apiKey,
    appUrl,
    forceLogin,
    fetch: fetch2,
    input,
    messages,
    parent: parentArg,
    state: stateArg,
    stream,
    mode,
    schema,
    ...functionIdArgs
  } = args;
  const state = stateArg ?? _internalGetGlobalState();
  await state.login({
    orgName,
    apiKey,
    appUrl,
    forceLogin,
    fetch: fetch2
  });
  const parent = parentArg ? typeof parentArg === "string" ? parentArg : await parentArg.export() : await getSpanParentObject().export();
  const functionId = functionIdSchema.safeParse({
    project_name: functionIdArgs.projectName,
    slug: functionIdArgs.slug,
    global_function: functionIdArgs.globalFunction,
    prompt_session_id: functionIdArgs.promptSessionId,
    prompt_session_function_id: functionIdArgs.promptSessionFunctionId,
    version: functionIdArgs.version
  });
  if (!functionId.success) {
    throw new Error(
      `Invalid function ID arguments: ${functionId.error.message}`
    );
  }
  const request = {
    ...functionId.data,
    input,
    messages,
    parent,
    stream,
    mode
  };
  const resp = await state.proxyConn().post(`function/invoke`, request, {
    headers: {
      Accept: stream ? "text/event-stream" : "application/json"
    }
  });
  if (stream) {
    if (!resp.body) {
      throw new Error("Received empty stream body");
    }
    return new BraintrustStream(resp.body);
  } else {
    const data = await resp.json();
    return schema ? schema.parse(data) : data;
  }
}

// src/wrappers/oai.ts
import { SpanTypeAttribute as SpanTypeAttribute2 } from "@braintrust/core";
import { mergeDicts as mergeDicts2 } from "@braintrust/core";
function wrapOpenAI(openai) {
  if (openai?.chat?.completions?.create) {
    return wrapOpenAIv4(openai);
  } else {
    console.warn("Unsupported OpenAI library (potentially v3). Not wrapping.");
    return openai;
  }
}
globalThis.__inherited_braintrust_wrap_openai = wrapOpenAI;
function wrapOpenAIv4(openai) {
  let completionProxy = new Proxy(openai.chat.completions, {
    get(target, name, receiver) {
      const baseVal = Reflect.get(target, name, receiver);
      if (name === "create") {
        return wrapChatCompletion(baseVal.bind(target));
      }
      return baseVal;
    }
  });
  let chatProxy = new Proxy(openai.chat, {
    get(target, name, receiver) {
      if (name === "completions") {
        return completionProxy;
      }
      return Reflect.get(target, name, receiver);
    }
  });
  let embeddingProxy = new Proxy(openai.embeddings, {
    get(target, name, receiver) {
      const baseVal = Reflect.get(target, name, receiver);
      if (name === "create") {
        return wrapEmbeddings(baseVal.bind(target));
      }
      return baseVal;
    }
  });
  let betaProxy;
  if (openai.beta?.chat?.completions?.stream) {
    let betaChatCompletionProxy = new Proxy(openai?.beta?.chat.completions, {
      get(target, name, receiver) {
        const baseVal = Reflect.get(target, name, receiver);
        if (name === "parse") {
          return wrapBetaChatCompletionParse(baseVal.bind(target));
        } else if (name === "stream") {
          return wrapBetaChatCompletionStream(baseVal.bind(target));
        }
        return baseVal;
      }
    });
    let betaChatProxy = new Proxy(openai.beta.chat, {
      get(target, name, receiver) {
        if (name === "completions") {
          return betaChatCompletionProxy;
        }
        return Reflect.get(target, name, receiver);
      }
    });
    betaProxy = new Proxy(openai.beta, {
      get(target, name, receiver) {
        if (name === "chat") {
          return betaChatProxy;
        }
        return Reflect.get(target, name, receiver);
      }
    });
  }
  let proxy = new Proxy(openai, {
    get(target, name, receiver) {
      if (name === "chat") {
        return chatProxy;
      }
      if (name === "embeddings") {
        return embeddingProxy;
      }
      if (name === "beta" && betaProxy) {
        return betaProxy;
      }
      return Reflect.get(target, name, receiver);
    }
  });
  return proxy;
}
function logCompletionResponse(startTime, response, span) {
  span.log({
    output: response.choices,
    metrics: {
      time_to_first_token: getCurrentUnixTimestamp() - startTime,
      tokens: response.usage?.total_tokens,
      prompt_tokens: response.usage?.prompt_tokens,
      completion_tokens: response.usage?.completion_tokens
    }
  });
}
function wrapBetaChatCompletionParse(completion) {
  return async (allParams) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts2(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: SpanTypeAttribute2.LLM
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    const ret = await completion(params);
    try {
      logCompletionResponse(startTime, ret, span);
      return ret;
    } finally {
      span.end();
    }
  };
}
function wrapBetaChatCompletionStream(completion) {
  return (allParams) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts2(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: SpanTypeAttribute2.LLM
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    const ret = completion(params);
    let first = true;
    ret.on("chunk", (_chunk) => {
      if (first) {
        const now2 = getCurrentUnixTimestamp();
        span.log({
          metrics: {
            time_to_first_token: now2 - startTime
          }
        });
        first = false;
      }
    });
    ret.on("chatCompletion", (completion2) => {
      span.log({
        output: completion2.choices
      });
    });
    ret.on("end", () => {
      span.end();
    });
    return ret;
  };
}
var LEGACY_CACHED_HEADER = "x-cached";
var X_CACHED_HEADER = "x-bt-cached";
function parseCachedHeader(value) {
  return isEmpty(value) ? void 0 : ["true", "hit"].includes(value.toLowerCase()) ? 1 : 0;
}
function logHeaders(response, span) {
  const cachedHeader = response.headers.get(X_CACHED_HEADER);
  if (isEmpty(cachedHeader)) {
    const legacyCacheHeader = response.headers.get(LEGACY_CACHED_HEADER);
    if (!isEmpty(legacyCacheHeader)) {
      span.log({
        metrics: {
          cached: parseCachedHeader(legacyCacheHeader)
        }
      });
    }
  } else {
    span.log({
      metrics: {
        cached: parseCachedHeader(cachedHeader)
      }
    });
  }
}
function wrapChatCompletion(completion) {
  return async (allParams, options) => {
    const { span_info: _, ...params } = allParams;
    const span = startSpan(
      mergeDicts2(
        {
          name: "Chat Completion",
          spanAttributes: {
            type: SpanTypeAttribute2.LLM
          }
        },
        parseChatCompletionParams(allParams)
      )
    );
    const startTime = getCurrentUnixTimestamp();
    if (params.stream) {
      const { data: ret, response } = await completion(
        // We could get rid of this type coercion if we could somehow enforce
        // that `P extends ChatParams` BUT does not have the property
        // `span_info`.
        params,
        options
      ).withResponse();
      logHeaders(response, span);
      const wrapperStream = new WrapperStream(span, startTime, ret.iterator());
      ret.iterator = () => wrapperStream[Symbol.asyncIterator]();
      return ret;
    } else {
      try {
        const { data: ret, response } = await completion(
          params,
          options
        ).withResponse();
        logHeaders(response, span);
        const { messages, ...rest } = params;
        span.log({
          input: messages,
          metadata: {
            ...rest
          }
        });
        logCompletionResponse(startTime, ret, span);
        return ret;
      } finally {
        span.end();
      }
    }
  };
}
function parseChatCompletionParams(allParams) {
  const { span_info, ...params } = allParams;
  const { metadata: spanInfoMetadata, ...spanInfoRest } = span_info ?? {};
  let ret = {
    ...spanInfoRest,
    event: {
      metadata: spanInfoMetadata
    }
  };
  const { messages, ...paramsRest } = params;
  return mergeDicts2(ret, { event: { input: messages, metadata: paramsRest } });
}
function wrapEmbeddings(create) {
  return async (allParams, options) => {
    const { span_info: _, ...params } = allParams;
    return traced(
      async (span) => {
        const { data: result, response } = await create(
          params,
          options
        ).withResponse();
        logHeaders(response, span);
        const embedding_length = result.data[0].embedding.length;
        span.log({
          // TODO: Add a flag to control whether to log the full embedding vector,
          // possibly w/ JSON compression.
          output: { embedding_length },
          metrics: {
            tokens: result.usage?.total_tokens,
            prompt_tokens: result.usage?.prompt_tokens
          }
        });
        return result;
      },
      mergeDicts2(
        {
          name: "Embedding",
          spanAttributes: {
            type: SpanTypeAttribute2.LLM
          }
        },
        parseEmbeddingParams(allParams)
      )
    );
  };
}
function parseEmbeddingParams(allParams) {
  const { span_info, ...params } = allParams;
  const { metadata: spanInfoMetadata, ...spanInfoRest } = span_info ?? {};
  let ret = {
    ...spanInfoRest,
    event: {
      metadata: spanInfoMetadata
    }
  };
  const { input, ...paramsRest } = params;
  return mergeDicts2(ret, { event: { input, metadata: paramsRest } });
}
function postprocessStreamingResults(allResults) {
  let role = void 0;
  let content = void 0;
  let tool_calls = void 0;
  let finish_reason = void 0;
  let metrics = {};
  for (const result of allResults) {
    if (result.usage) {
      metrics = {
        ...metrics,
        tokens: result.usage.total_tokens,
        prompt_tokens: result.usage.prompt_tokens,
        completion_tokens: result.usage.completion_tokens
      };
    }
    const delta = result.choices?.[0]?.delta;
    if (!delta) {
      continue;
    }
    if (!role && delta.role) {
      role = delta.role;
    }
    if (delta.finish_reason) {
      finish_reason = delta.finish_reason;
    }
    if (delta.content) {
      content = (content || "") + delta.content;
    }
    if (delta.tool_calls) {
      if (!tool_calls) {
        tool_calls = [
          {
            id: delta.tool_calls[0].id,
            type: delta.tool_calls[0].type,
            function: delta.tool_calls[0].function
          }
        ];
      } else {
        tool_calls[0].function.arguments += delta.tool_calls[0].function.arguments;
      }
    }
  }
  return {
    metrics,
    output: [
      {
        index: 0,
        message: {
          role,
          content,
          tool_calls
        },
        logprobs: null,
        finish_reason
      }
    ]
  };
}
var WrapperStream = class {
  span;
  iter;
  startTime;
  constructor(span, startTime, iter) {
    this.span = span;
    this.iter = iter;
    this.startTime = startTime;
  }
  async *[Symbol.asyncIterator]() {
    let first = true;
    let allResults = [];
    try {
      for await (const item of this.iter) {
        if (first) {
          const now2 = getCurrentUnixTimestamp();
          this.span.log({
            metrics: {
              time_to_first_token: now2 - this.startTime
            }
          });
          first = false;
        }
        allResults.push(item);
        yield item;
      }
      this.span.log({
        ...postprocessStreamingResults(allResults)
      });
    } finally {
      this.span.end();
    }
  }
};

// src/browser.ts
configureBrowser();
var browser_default = exports_browser_exports;
export {
  Attachment,
  BraintrustState,
  BraintrustStream,
  Dataset,
  Experiment,
  FailedHTTPResponse,
  LEGACY_CACHED_HEADER,
  Logger,
  NOOP_SPAN,
  NoopSpan,
  Prompt,
  ReadonlyExperiment,
  SpanImpl,
  X_CACHED_HEADER,
  _exportsForTestingOnly,
  _internalGetGlobalState,
  _internalSetInitialState,
  braintrustStreamChunkSchema,
  createFinalValuePassThroughStream,
  currentExperiment,
  currentLogger,
  currentSpan,
  browser_default as default,
  devNullWritableStream,
  flush,
  getSpanParentObject,
  init,
  initDataset,
  initExperiment,
  initLogger,
  invoke,
  loadPrompt,
  log,
  logError,
  login,
  loginToState,
  newId,
  parseCachedHeader,
  permalink,
  renderMessage,
  setFetch,
  spanComponentsToObjectId,
  startSpan,
  summarize,
  traceable,
  traced,
  updateSpan,
  withCurrent,
  withDataset,
  withExperiment,
  withLogger,
  wrapOpenAI,
  wrapOpenAIv4,
  wrapTraced
};
