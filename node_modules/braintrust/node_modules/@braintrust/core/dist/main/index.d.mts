declare const TRANSACTION_ID_FIELD = "_xact_id";
declare const OBJECT_DELETE_FIELD = "_object_delete";
declare const CREATED_FIELD = "created";
declare const ID_FIELD = "id";
declare const IS_MERGE_FIELD = "_is_merge";
declare const MERGE_PATHS_FIELD = "_merge_paths";
declare const AUDIT_SOURCE_FIELD = "_audit_source";
declare const AUDIT_METADATA_FIELD = "_audit_metadata";
declare const VALID_SOURCES: readonly ["app", "api", "external"];
type Source = typeof VALID_SOURCES[number];
declare const PARENT_ID_FIELD = "_parent_id";
type TransactionId = string;
declare const ALL_ROW_ID_FIELDS: string[];

declare function mergeRowBatch<T extends {
    id: string;
    [IS_MERGE_FIELD]?: boolean;
    [PARENT_ID_FIELD]?: string;
}>(rows: T[]): T[][];
declare function batchItems(args: {
    items: string[][];
    batchMaxNumItems?: number;
    batchMaxNumBytes?: number;
}): string[][][];

type IdField = {
    id: string;
};
type InputField = {
    input: unknown;
};
type InputsField = {
    inputs: unknown;
};
type OtherExperimentLogFields = {
    output: unknown;
    expected: unknown;
    tags: string[];
    scores: Record<string, number | null>;
    metadata: Record<string, unknown>;
    metrics: Record<string, unknown>;
    datasetRecordId: string;
};
type ExperimentLogPartialArgs = Partial<OtherExperimentLogFields> & Partial<InputField | InputsField>;
type ExperimentLogFullArgs = Partial<Omit<OtherExperimentLogFields, "output" | "scores">> & Required<Pick<OtherExperimentLogFields, "output" | "scores">> & Partial<InputField | InputsField> & Partial<IdField>;
type LogFeedbackFullArgs = IdField & Partial<Omit<OtherExperimentLogFields, "output" | "metrics" | "datasetRecordId"> & {
    comment: string;
    source: Source;
}>;
interface ParentExperimentIds {
    kind: "experiment";
    project_id: string;
    experiment_id: string;
}
interface ParentProjectLogIds {
    kind: "project_log";
    org_id: string;
    project_id: string;
    log_id: "g";
}
type LogCommentFullArgs = IdField & {
    created: string;
    origin: {
        id: string;
    };
    comment: {
        text: string;
    };
    [AUDIT_SOURCE_FIELD]: Source;
    [AUDIT_METADATA_FIELD]?: Record<string, unknown>;
} & Omit<ParentExperimentIds | ParentProjectLogIds, "kind">;
type SanitizedExperimentLogPartialArgs = Partial<OtherExperimentLogFields> & Partial<InputField>;
type ExperimentEvent = Partial<InputField> & Partial<OtherExperimentLogFields> & {
    id: string;
    span_id?: string;
    root_span_id?: string;
    project_id: string;
    experiment_id: string;
    [IS_MERGE_FIELD]: boolean;
} & Partial<{
    created: string;
    span_parents: string[];
    span_attributes: Record<string, unknown>;
    context: Record<string, unknown>;
    [PARENT_ID_FIELD]: string;
    [AUDIT_SOURCE_FIELD]: Source;
    [AUDIT_METADATA_FIELD]?: Record<string, unknown>;
}>;
type DatasetEvent = {
    input?: unknown;
    tags?: string[];
    metadata?: unknown;
    id: string;
    project_id: string;
    dataset_id: string;
    created: string;
} & ({
    expected?: unknown;
} | {
    output?: unknown;
});
type LoggingEvent = Omit<ExperimentEvent, "experiment_id"> & {
    org_id: string;
    log_id: "g";
};
type CommentEvent = IdField & {
    created: string;
    origin: {
        id: string;
    };
    comment: {
        text: string;
    };
    [AUDIT_SOURCE_FIELD]: Source;
    [AUDIT_METADATA_FIELD]?: Record<string, unknown>;
} & Omit<ParentExperimentIds | ParentProjectLogIds, "kind">;
type BackgroundLogEvent = ExperimentEvent | DatasetEvent | LoggingEvent | CommentEvent;
declare const DEFAULT_IS_LEGACY_DATASET = true;
interface LegacyDatasetRecord {
    id: string;
    input: any;
    output: any;
    metadata: any;
}
interface NewDatasetRecord {
    id: string;
    input: any;
    expected: any;
    tags: any;
    metadata: any;
}
type DatasetRecord<IsLegacyDataset extends boolean = typeof DEFAULT_IS_LEGACY_DATASET> = IsLegacyDataset extends true ? LegacyDatasetRecord : NewDatasetRecord;
type AnyDatasetRecord = DatasetRecord<boolean>;
declare function ensureDatasetRecord<IsLegacyDataset extends boolean = typeof DEFAULT_IS_LEGACY_DATASET>(r: AnyDatasetRecord, legacy: IsLegacyDataset): DatasetRecord<IsLegacyDataset>;
declare function ensureLegacyDatasetRecord(r: AnyDatasetRecord): DatasetRecord<true>;
declare function ensureNewDatasetRecord(r: AnyDatasetRecord): DatasetRecord<false>;
declare function makeLegacyEvent(e: BackgroundLogEvent): BackgroundLogEvent;

interface Score {
    name: string;
    score: number | null;
    metadata?: Record<string, unknown>;
    /**
     * @deprecated
     */
    error?: unknown;
}
type ScorerArgs<Output, Extra> = {
    output: Output;
    expected?: Output;
} & Extra;
type Scorer<Output, Extra> = (args: ScorerArgs<Output, Extra>) => Score | Promise<Score>;

declare function mergeDicts(mergeInto: Record<string, unknown>, mergeFrom: Record<string, unknown>): Record<string, unknown>;
declare function capitalize(s: string, sep?: string): string;
declare function constructJsonArray(items: string[]): string;
declare function mapAt<K, V>(m: Map<K, V>, k: K): V;

declare enum SpanTypeAttribute {
    LLM = "llm",
    SCORE = "score",
    FUNCTION = "function",
    EVAL = "eval",
    TASK = "task",
    TOOL = "tool"
}

interface RepoInfo {
    commit?: string;
    branch?: string;
    tag?: string;
    dirty?: boolean;
    author_name?: string;
    author_email?: string;
    commit_message?: string;
    commit_time?: string;
    git_diff?: string;
}
type GitFields = Array<keyof RepoInfo>;
type CollectMetadata = "all" | "none" | "some";
type GitMetadataSettings = {
    collect: CollectMetadata;
    fields?: GitFields;
};
declare function mergeGitMetadataSettings(s1: GitMetadataSettings, s2: GitMetadataSettings): GitMetadataSettings;

declare function prettifyXact(valueString: TransactionId): string;
declare function loadPrettyXact(encodedHex: string): TransactionId;

export { ALL_ROW_ID_FIELDS, AUDIT_METADATA_FIELD, AUDIT_SOURCE_FIELD, type AnyDatasetRecord, type BackgroundLogEvent, CREATED_FIELD, type CollectMetadata, type CommentEvent, DEFAULT_IS_LEGACY_DATASET, type DatasetEvent, type DatasetRecord, type ExperimentEvent, type ExperimentLogFullArgs, type ExperimentLogPartialArgs, type GitFields, type GitMetadataSettings, ID_FIELD, IS_MERGE_FIELD, type IdField, type InputField, type InputsField, type LogCommentFullArgs, type LogFeedbackFullArgs, type LoggingEvent, MERGE_PATHS_FIELD, OBJECT_DELETE_FIELD, type OtherExperimentLogFields, PARENT_ID_FIELD, type ParentExperimentIds, type ParentProjectLogIds, type RepoInfo, type SanitizedExperimentLogPartialArgs, type Score, type Scorer, type ScorerArgs, type Source, SpanTypeAttribute, TRANSACTION_ID_FIELD, type TransactionId, VALID_SOURCES, batchItems, capitalize, constructJsonArray, ensureDatasetRecord, ensureLegacyDatasetRecord, ensureNewDatasetRecord, loadPrettyXact, makeLegacyEvent, mapAt, mergeDicts, mergeGitMetadataSettings, mergeRowBatch, prettifyXact };
