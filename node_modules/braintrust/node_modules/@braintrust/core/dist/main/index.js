"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ALL_ROW_ID_FIELDS: () => ALL_ROW_ID_FIELDS,
  AUDIT_METADATA_FIELD: () => AUDIT_METADATA_FIELD,
  AUDIT_SOURCE_FIELD: () => AUDIT_SOURCE_FIELD,
  CREATED_FIELD: () => CREATED_FIELD,
  DEFAULT_IS_LEGACY_DATASET: () => DEFAULT_IS_LEGACY_DATASET,
  ID_FIELD: () => ID_FIELD,
  IS_MERGE_FIELD: () => IS_MERGE_FIELD,
  MERGE_PATHS_FIELD: () => MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD: () => OBJECT_DELETE_FIELD,
  PARENT_ID_FIELD: () => PARENT_ID_FIELD,
  SpanTypeAttribute: () => SpanTypeAttribute,
  TRANSACTION_ID_FIELD: () => TRANSACTION_ID_FIELD,
  VALID_SOURCES: () => VALID_SOURCES,
  batchItems: () => batchItems,
  capitalize: () => capitalize,
  constructJsonArray: () => constructJsonArray,
  ensureDatasetRecord: () => ensureDatasetRecord,
  ensureLegacyDatasetRecord: () => ensureLegacyDatasetRecord,
  ensureNewDatasetRecord: () => ensureNewDatasetRecord,
  loadPrettyXact: () => loadPrettyXact,
  makeLegacyEvent: () => makeLegacyEvent,
  mapAt: () => mapAt,
  mergeDicts: () => mergeDicts,
  mergeGitMetadataSettings: () => mergeGitMetadataSettings,
  mergeRowBatch: () => mergeRowBatch,
  prettifyXact: () => prettifyXact
});
module.exports = __toCommonJS(src_exports);

// src/db_fields.ts
var TRANSACTION_ID_FIELD = "_xact_id";
var OBJECT_DELETE_FIELD = "_object_delete";
var CREATED_FIELD = "created";
var ID_FIELD = "id";
var IS_MERGE_FIELD = "_is_merge";
var MERGE_PATHS_FIELD = "_merge_paths";
var AUDIT_SOURCE_FIELD = "_audit_source";
var AUDIT_METADATA_FIELD = "_audit_metadata";
var VALID_SOURCES = ["app", "api", "external"];
var PARENT_ID_FIELD = "_parent_id";
var ALL_ROW_ID_FIELDS = [
  ID_FIELD,
  TRANSACTION_ID_FIELD,
  CREATED_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD
];

// src/util.ts
function mergeDicts(mergeInto, mergeFrom) {
  for (const [k, mergeFromV] of Object.entries(mergeFrom)) {
    const mergeIntoV = mergeInto[k];
    if (mergeIntoV instanceof Object && !Array.isArray(mergeIntoV) && mergeFrom instanceof Object && !Array.isArray(mergeFromV)) {
      mergeDicts(
        mergeIntoV,
        mergeFromV
      );
    } else {
      mergeInto[k] = mergeFromV;
    }
  }
  return mergeInto;
}
function capitalize(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toUpperCase() + s2.slice(1) : s2).join(sep || "");
}
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}

// src/graph_util.ts
function depthFirstSearch(args) {
  var _a;
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = (_a = args.visitationOrder) != null ? _a : [...graph.keys()];
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      lastVisitF == null ? void 0 : lastVisitF(vertex);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    firstVisitF == null ? void 0 : firstVisitF(vertex, { parentVertex: extras.parentVertex });
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = (vertex, args) => {
    const label = (args == null ? void 0 : args.parentVertex) !== void 0 ? mapAt(vertexLabels, args == null ? void 0 : args.parentVertex) : labelCounter++;
    vertexLabels.set(vertex, label);
  };
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = (vertex) => {
    reverseOrdering.push(vertex);
  };
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}

// src/merge_row_batch.ts
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      (useParentIdForId != null ? useParentIdForId : false) ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrustdata.com for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
function batchItems(args) {
  var _a, _b;
  let { items } = args;
  const batchMaxNumItems = (_a = args.batchMaxNumItems) != null ? _a : Number.POSITIVE_INFINITY;
  const batchMaxNumBytes = (_b = args.batchMaxNumBytes) != null ? _b : Number.POSITIVE_INFINITY;
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}

// src/object.ts
var DEFAULT_IS_LEGACY_DATASET = true;
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
function makeLegacyEvent(e) {
  if (!("dataset_id" in e) || !("expected" in e)) {
    return e;
  }
  const event = {
    ...e,
    output: e.expected
  };
  delete event.expected;
  if (MERGE_PATHS_FIELD in event) {
    for (const path of event[MERGE_PATHS_FIELD] || []) {
      if (path.length > 0 && path[0] === "expected") {
        path[0] = "output";
      }
    }
  }
  return event;
}

// src/span_types.ts
var SpanTypeAttribute = /* @__PURE__ */ ((SpanTypeAttribute2) => {
  SpanTypeAttribute2["LLM"] = "llm";
  SpanTypeAttribute2["SCORE"] = "score";
  SpanTypeAttribute2["FUNCTION"] = "function";
  SpanTypeAttribute2["EVAL"] = "eval";
  SpanTypeAttribute2["TASK"] = "task";
  SpanTypeAttribute2["TOOL"] = "tool";
  return SpanTypeAttribute2;
})(SpanTypeAttribute || {});

// src/git_fields.ts
function mergeGitMetadataSettings(s1, s2) {
  var _a;
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = ((_a = s1.fields) != null ? _a : []).filter((f) => {
    var _a2;
    return ((_a2 = s2.fields) != null ? _a2 : []).includes(f);
  });
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}

// src/xact-ids.ts
var TOP_BITS = BigInt("0x0DE1") << BigInt(48);
var MOD = BigInt(1) << BigInt(64);
var COPRIME = BigInt("205891132094649");
var COPRIME_INVERSE = BigInt("1522336535492693385");
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
function loadPrettyXact(encodedHex) {
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ALL_ROW_ID_FIELDS,
  AUDIT_METADATA_FIELD,
  AUDIT_SOURCE_FIELD,
  CREATED_FIELD,
  DEFAULT_IS_LEGACY_DATASET,
  ID_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD,
  PARENT_ID_FIELD,
  SpanTypeAttribute,
  TRANSACTION_ID_FIELD,
  VALID_SOURCES,
  batchItems,
  capitalize,
  constructJsonArray,
  ensureDatasetRecord,
  ensureLegacyDatasetRecord,
  ensureNewDatasetRecord,
  loadPrettyXact,
  makeLegacyEvent,
  mapAt,
  mergeDicts,
  mergeGitMetadataSettings,
  mergeRowBatch,
  prettifyXact
});
