// typespecs/api_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi3 } from "@asteasolutions/zod-to-openapi";
import { z as z5 } from "zod";

// typespecs/app_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi2 } from "@asteasolutions/zod-to-openapi";
import { z as z4 } from "zod";

// typespecs/common_types.ts
import { z } from "zod";
var literalSchema = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.null()
]);
var jsonSchema = z.lazy(
  () => z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);
var datetimeStringSchema = z.string().datetime({ offset: true });
var objectTypes = z.enum([
  "project",
  "experiment",
  "dataset",
  "prompt",
  "role",
  "team",
  "acl",
  "user"
]);
var objectTypesWithEvent = z.enum([
  "project",
  "experiment",
  "dataset",
  "prompt"
]);
function getEventObjectType(objectType) {
  return objectType === "project" ? "project_logs" : objectType;
}
function getEventObjectDescription(objectType) {
  return getEventObjectType(objectType).replace("_", " ");
}
function getObjectArticle(objectType) {
  return ["acl", "experiment"].includes(objectType) ? "an" : "a";
}

// typespecs/custom_types.ts
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z as z2 } from "zod";
extendZodWithOpenApi(z2);
var modeSchema = z2.enum(["default", "stainless"]);
var _a;
var mode = modeSchema.parse(
  typeof process === "undefined" ? "default" : ((_a = process == null ? void 0 : process.env) == null ? void 0 : _a.BRAINTRUST_TYPESPECS_MODE) || "default"
);
var modeToTypes = {
  default: {
    any: z2.any(),
    literalTrue: z2.literal(true),
    literalFalse: z2.literal(false)
  },
  stainless: {
    // Stainless requires schemas which are completely permissive to be
    // tagged.
    any: z2.any().openapi({ ["x-stainless-any"]: true }),
    // Stainless does not support boolean literals in all SDKs.
    literalTrue: z2.boolean(),
    literalFalse: z2.boolean()
  }
};
var customTypes = modeToTypes[mode];

// typespecs/prompt.ts
import { z as z3 } from "zod";
var messageRoleSchema = z3.enum([
  "system",
  "user",
  "assistant",
  "function",
  "tool",
  "model"
]);
var functionCallSchema = z3.object({
  name: z3.string(),
  arguments: z3.string()
});
var toolCallSchema = z3.object({
  id: z3.string(),
  function: z3.object({
    arguments: z3.string(),
    name: z3.string()
  }),
  type: z3.literal("function")
});
var messageSchema = z3.object({
  content: z3.string().default(""),
  role: messageRoleSchema,
  name: z3.string().optional(),
  function_call: z3.union([z3.string(), functionCallSchema]).optional(),
  tool_calls: z3.array(toolCallSchema).optional()
});
var promptBlockDataSchema = z3.union([
  z3.object({
    type: z3.literal("completion"),
    content: z3.string()
  }),
  z3.object({
    type: z3.literal("chat"),
    messages: z3.array(messageSchema),
    tools: z3.string().optional()
  })
]);
var braintrustModelParamsSchema = z3.object({
  use_cache: z3.boolean().optional()
});
var openAIModelParamsSchema = z3.object({
  temperature: z3.number(),
  top_p: z3.number().optional(),
  max_tokens: z3.number().optional(),
  frequency_penalty: z3.number().optional(),
  presence_penalty: z3.number().optional(),
  response_format: z3.union([z3.literal(null), z3.object({ type: z3.literal("json_object") })]).optional(),
  tool_choice: z3.union([
    z3.literal("auto"),
    z3.literal("none"),
    z3.object({
      type: z3.literal("function"),
      function: z3.object({ name: z3.string() })
    })
  ]).optional()
});
var anthropicModelParamsSchema = z3.object({
  max_tokens: z3.number(),
  temperature: z3.number(),
  top_p: z3.number().optional(),
  top_k: z3.number().optional(),
  max_tokens_to_sample: z3.number().optional().describe("This is a legacy parameter that should not be used.")
});
var googleModelParamsSchema = z3.object({
  temperature: z3.number(),
  maxOutputTokens: z3.number().optional(),
  topP: z3.number().optional(),
  topK: z3.number().optional()
});
var jsCompletionParamsSchema = z3.object({});
var modelParamsSchema = braintrustModelParamsSchema.and(
  z3.union([
    openAIModelParamsSchema,
    anthropicModelParamsSchema,
    googleModelParamsSchema,
    jsCompletionParamsSchema
  ])
);
var promptOptionsSchema = z3.object({
  model: z3.string().optional(),
  params: modelParamsSchema.optional(),
  position: z3.string().optional()
});
var promptDataSchema = z3.object({
  prompt: promptBlockDataSchema.nullish(),
  options: promptOptionsSchema.nullish(),
  origin: z3.object({
    prompt_id: z3.string().optional(),
    prompt_version: z3.string().optional()
  }).nullish()
}).openapi("PromptData");

// typespecs/app_types.ts
extendZodWithOpenApi2(z4);
function generateBaseTableSchema(objectName, opts) {
  let nameDescription = `Name of the ${objectName}`;
  if (opts == null ? void 0 : opts.uniqueName) {
    nameDescription += `. Within a project, ${objectName} names are unique`;
  }
  return z4.object({
    id: z4.string().uuid().describe(`Unique identifier for the ${objectName}`),
    project_id: z4.string().uuid().describe(
      `Unique identifier for the project that the ${objectName} belongs under`
    ),
    name: z4.string().describe(nameDescription),
    description: z4.string().nullish().describe(`Textual description of the ${objectName}`),
    created: datetimeStringSchema.nullish().describe(`Date of ${objectName} creation`),
    deleted_at: datetimeStringSchema.nullish().describe(
      `Date of ${objectName} deletion, or null if the ${objectName} is still active`
    ),
    user_id: z4.string().uuid().nullish().describe(`Identifies the user who created the ${objectName}`),
    metadata: z4.record(customTypes.any).nullish().describe(`User-controlled metadata about the ${objectName}`)
  });
}
var userBaseSchema = generateBaseTableSchema("user");
var userSchema = z4.object({
  id: userBaseSchema.shape.id,
  given_name: z4.string().nullish().describe("Given name of the user"),
  family_name: z4.string().nullish().describe("Family name of the user"),
  email: z4.string().nullish().describe("The user's email"),
  avatar_url: z4.string().nullish().describe("URL of the user's Avatar image"),
  created: userBaseSchema.shape.created
}).strict().openapi("User");
var organizationBaseSchema = generateBaseTableSchema("organization");
var organizationSchema = z4.object({
  id: organizationBaseSchema.shape.id,
  name: organizationBaseSchema.shape.name.nullish(),
  api_url: z4.string().nullish(),
  created: organizationBaseSchema.shape.created
}).strict().openapi("Organization");
var memberSchema = z4.object({
  org_id: organizationSchema.shape.id,
  user_id: userSchema.shape.id
}).strict().openapi("Member");
var meSchema = z4.object({
  id: userSchema.shape.id,
  organizations: z4.object({
    id: memberSchema.shape.org_id,
    name: organizationSchema.shape.name
  }).array()
}).strict().openapi("Me");
var apiKeyBaseSchema = generateBaseTableSchema("api key");
var apiKeySchema = z4.object({
  id: apiKeyBaseSchema.shape.id,
  created: apiKeyBaseSchema.shape.created,
  key_hash: z4.string(),
  name: apiKeyBaseSchema.shape.name,
  preview_name: z4.string(),
  user_id: userSchema.shape.id.nullish(),
  org_id: organizationSchema.shape.id.nullish()
}).strict().openapi("ApiKey");
var projectBaseSchema = generateBaseTableSchema("project");
var projectSchema = z4.object({
  id: projectBaseSchema.shape.id,
  org_id: z4.string().uuid().describe(
    "Unique id for the organization that the project belongs under"
  ),
  name: projectBaseSchema.shape.name,
  created: projectBaseSchema.shape.created,
  deleted_at: projectBaseSchema.shape.deleted_at,
  user_id: projectBaseSchema.shape.user_id
}).strict().openapi("Project");
var datasetBaseSchema = generateBaseTableSchema("dataset", {
  uniqueName: true
});
var datasetSchema = z4.object({
  id: datasetBaseSchema.shape.id,
  project_id: datasetBaseSchema.shape.project_id.nullish(),
  name: datasetBaseSchema.shape.name,
  description: datasetBaseSchema.shape.description,
  created: datasetBaseSchema.shape.created,
  deleted_at: datasetBaseSchema.shape.deleted_at,
  user_id: datasetBaseSchema.shape.user_id
}).strict().openapi("Dataset");
var promptBaseSchema = generateBaseTableSchema("prompt");
var promptSchema = z4.object({
  id: promptBaseSchema.shape.id,
  project_id: promptBaseSchema.shape.project_id,
  name: promptBaseSchema.shape.name,
  slug: z4.string().describe("Unique identifier for the prompt"),
  description: promptBaseSchema.shape.description,
  prompt_data: promptDataSchema.nullish().describe("The prompt, model, and its parameters"),
  tags: z4.array(z4.string()).nullish().describe("A list of tags for the prompt")
});
var repoInfoSchema = z4.object({
  commit: z4.string().nullish().describe("SHA of most recent commit"),
  branch: z4.string().nullish().describe("Name of the branch the most recent commit belongs to"),
  tag: z4.string().nullish().describe("Name of the tag on the most recent commit"),
  dirty: z4.boolean().nullish().describe(
    "Whether or not the repo had uncommitted changes when snapshotted"
  ),
  author_name: z4.string().nullish().describe("Name of the author of the most recent commit"),
  author_email: z4.string().nullish().describe("Email of the author of the most recent commit"),
  commit_message: z4.string().nullish().describe("Most recent commit message"),
  commit_time: z4.string().nullish().describe("Time of the most recent commit"),
  git_diff: z4.string().nullish().describe(
    "If the repo was dirty when run, this includes the diff between the current state of the repo and the most recent commit."
  )
}).describe(
  "Metadata about the state of the repo when the experiment was created"
).openapi("RepoInfo");
var experimentBaseSchema = generateBaseTableSchema("experiment", {
  uniqueName: true
});
var experimentSchema = z4.object({
  id: experimentBaseSchema.shape.id,
  project_id: experimentBaseSchema.shape.project_id,
  name: experimentBaseSchema.shape.name,
  description: experimentBaseSchema.shape.description,
  created: experimentBaseSchema.shape.created,
  repo_info: repoInfoSchema.nullish(),
  commit: z4.string().nullish().describe("Commit, taken directly from `repo_info.commit`"),
  base_exp_id: z4.string().uuid().nullish().describe(
    "Id of default base experiment to compare against when viewing this experiment"
  ),
  deleted_at: experimentBaseSchema.shape.deleted_at,
  dataset_id: z4.string().uuid().nullish().describe(
    "Identifier of the linked dataset, or null if the experiment is not linked to a dataset"
  ),
  dataset_version: z4.string().nullish().describe(
    "Version number of the linked dataset the experiment was run against. This can be used to reproduce the experiment after the dataset has been modified."
  ),
  public: z4.boolean().describe(
    "Whether or not the experiment is public. Public experiments can be viewed by anybody inside or outside the organization"
  ),
  user_id: experimentBaseSchema.shape.user_id,
  metadata: experimentBaseSchema.shape.metadata
}).strict().openapi("Experiment");
var privilegeEnum = z4.enum([
  "create",
  "read",
  "update",
  "delete",
  "create_acls",
  "read_acls",
  "update_acls",
  "delete_acls"
]).describe(
  [
    "Each privilege permits a certain type of operation on an object in the system",
    "Privileges can be assigned to to objects on an individual basis, or grouped into roles"
  ].join("\n\n")
);
var roleBaseSchema = generateBaseTableSchema("role");
var roleSchema = z4.object({
  id: roleBaseSchema.shape.id,
  org_id: z4.string().uuid().nullish().describe(
    [
      "Unique id for the organization that the role belongs under",
      "A null org_id indicates a system role, which may be assigned to anybody and inherited by any other role, but cannot be edited.",
      "It is forbidden to change the org after creating a role"
    ].join("\n\n")
  ),
  user_id: roleBaseSchema.shape.user_id,
  created: roleBaseSchema.shape.created,
  name: roleBaseSchema.shape.name,
  description: roleBaseSchema.shape.description,
  deleted_at: roleBaseSchema.shape.deleted_at,
  member_privileges: z4.array(privilegeEnum).nullish().describe("Privileges which belong to this role"),
  member_roles: z4.array(z4.string().uuid()).nullish().describe(
    [
      "Ids of the roles this role inherits from",
      "An inheriting role has all the privileges contained in its member roles, as well as all of their inherited privileges"
    ].join("\n\n")
  )
}).strict().describe(
  [
    "A role is a collection of privileges which can be granted as part of an ACL",
    "Roles can consist of individual privileges, as well as a set of roles they inherit from"
  ].join("\n\n")
).openapi("Role");
var teamBaseSchema = generateBaseTableSchema("team");
var teamSchema = z4.object({
  id: teamBaseSchema.shape.id,
  org_id: z4.string().uuid().describe(
    [
      "Unique id for the organization that the team belongs under",
      "It is forbidden to change the org after creating a team"
    ].join("\n\n")
  ),
  user_id: teamBaseSchema.shape.user_id,
  created: teamBaseSchema.shape.created,
  name: teamBaseSchema.shape.name,
  description: teamBaseSchema.shape.description,
  deleted_at: teamBaseSchema.shape.deleted_at,
  member_users: z4.array(z4.string().uuid()).nullish().describe("Ids of users which belong to this team"),
  member_teams: z4.array(z4.string().uuid()).nullish().describe(
    [
      "Ids of the teams this team inherits from",
      "An inheriting team has all the users contained in its member teams, as well as all of their inherited users"
    ].join("\n\n")
  )
}).strict().describe(
  [
    "A team is a collection of users which can be assigned an ACL",
    "Teams can consist of individual users, as well as a set of teams they inherit from"
  ].join("\n\n")
).openapi("Team");
var aclObjectTypeEnum = z4.enum([
  "organization",
  "project",
  "experiment",
  "dataset",
  "prompt",
  "prompt_session",
  "project_score",
  "project_tag",
  "team",
  "role"
]).describe("The object type that the ACL applies to");
var aclBaseSchema = generateBaseTableSchema("acl");
var aclObjectSchema = z4.object({
  id: aclBaseSchema.shape.id,
  object_type: aclObjectTypeEnum,
  object_id: z4.string().uuid().describe("The id of the object the ACL applies to"),
  _object_org_id: z4.string().uuid().describe("The organization the ACL's referred object belongs to"),
  created: aclBaseSchema.shape.created
}).strict();
var aclUserObjectSchema = z4.object({
  user_id: z4.string().uuid().describe("Id of the user the ACL applies to")
}).strict();
var aclTeamObjectSchema = z4.object({
  team_id: z4.string().uuid().describe("Id of the team the ACL applies to")
}).strict();
var aclPrivilegeObjectSchema = z4.object({
  privilege: privilegeEnum.describe("Privilege the ACL grants")
}).strict();
var aclRoleObjectSchema = z4.object({
  role_id: z4.string().uuid().describe("Role the ACL grants")
}).strict();
var aclSchema = z4.union([
  aclObjectSchema.merge(aclUserObjectSchema).merge(aclPrivilegeObjectSchema).openapi("UserPrivilegeAcl"),
  aclObjectSchema.merge(aclUserObjectSchema).merge(aclRoleObjectSchema).openapi("UserRoleAcl"),
  aclObjectSchema.merge(aclTeamObjectSchema).merge(aclPrivilegeObjectSchema).openapi("TeamPrivilegeAcl"),
  aclObjectSchema.merge(aclTeamObjectSchema).merge(aclRoleObjectSchema).openapi("TeamRoleAcl")
]).describe(
  [
    "An ACL grants a certain privilege or role to a certain user or team on an object",
    "ACLs are inherited across the object hierarchy. So for example, if a user has read privileges on a project, they will also have read privileges on any experiment, dataset, etc. created within that project"
  ].join("\n\n")
).openapi("Acl");
var appLimitSchema = z4.number().int().nonnegative().describe("Limit the number of objects to return");
function generateBaseTableOpSchema(objectName) {
  return z4.object({
    org_name: z4.string().nullish().describe(
      `For nearly all users, this parameter should be unnecessary. But in the rare case that your API key belongs to multiple organizations, you may specify the name of the organization the ${objectName} belongs in.`
    )
  });
}
var startingAfterSchema = z4.string().uuid().describe(
  [
    "Pagination cursor id.",
    "For example, if the final item in the last page you fetched had an id of `foo`, pass `starting_after=foo` to fetch the next page. Note: you may only pass one of `starting_after` and `ending_before`"
  ].join("\n\n")
).openapi("StartingAfter");
var endingBeforeSchema = z4.string().uuid().describe(
  [
    "Pagination cursor id.",
    "For example, if the initial item in the last page you fetched had an id of `foo`, pass `ending_before=foo` to fetch the previous page. Note: you may only pass one of `starting_after` and `ending_before`"
  ].join("\n\n")
).openapi("EndingBefore");
var createProjectBaseSchema = generateBaseTableOpSchema("project");
var createProjectSchema = z4.object({
  name: projectSchema.shape.name,
  org_name: createProjectBaseSchema.shape.org_name
}).strict().openapi("CreateProject");
var patchProjectSchema = z4.object({
  name: projectSchema.shape.name.nullish()
}).strict().openapi("PatchProject");
var createExperimentSchema = z4.object({
  project_id: experimentSchema.shape.project_id,
  name: experimentSchema.shape.name.nullish(),
  description: experimentSchema.shape.description,
  repo_info: experimentSchema.shape.repo_info,
  base_exp_id: experimentSchema.shape.base_exp_id,
  dataset_id: experimentSchema.shape.dataset_id,
  dataset_version: experimentSchema.shape.dataset_version,
  public: experimentSchema.shape.public.nullish(),
  metadata: experimentSchema.shape.metadata
}).strict().openapi("CreateExperiment");
var patchExperimentSchema = createExperimentSchema.omit({ project_id: true }).strict().openapi("PatchExperiment");
var createDatasetSchema = z4.object({
  project_id: datasetSchema.shape.project_id,
  name: datasetSchema.shape.name,
  description: datasetSchema.shape.description
}).strict().openapi("CreateDataset");
var patchDatasetSchema = z4.object({
  name: datasetSchema.shape.name.nullish(),
  description: datasetSchema.shape.description
}).strict().openapi("PatchDataset");
var createPromptSchema = promptSchema.omit({ id: true }).strict().openapi("CreatePrompt");
var patchPromptSchema = z4.object({
  name: promptSchema.shape.name.nullish(),
  description: promptSchema.shape.description.nullish(),
  prompt_data: promptSchema.shape.prompt_data.nullish(),
  tags: promptSchema.shape.tags.nullish()
}).strict().openapi("PatchPrompt");
var createRoleBaseSchema = generateBaseTableOpSchema("role");
var createRoleSchema = z4.object({
  name: roleSchema.shape.name,
  description: roleSchema.shape.description,
  member_privileges: roleSchema.shape.member_privileges,
  member_roles: roleSchema.shape.member_roles,
  org_name: createRoleBaseSchema.shape.org_name
}).strict().openapi("CreateRole");
var patchRoleSchema = createRoleSchema.omit({ name: true, org_name: true }).merge(
  z4.object({
    name: createRoleSchema.shape.name.nullish()
  })
).openapi("PatchRole");
var createTeamBaseSchema = generateBaseTableOpSchema("team");
var createTeamSchema = z4.object({
  name: teamSchema.shape.name,
  description: teamSchema.shape.description,
  member_users: teamSchema.shape.member_users,
  member_teams: teamSchema.shape.member_teams,
  org_name: createTeamBaseSchema.shape.org_name
}).strict().openapi("CreateTeam");
var patchTeamSchema = createTeamSchema.omit({ name: true, org_name: true }).merge(
  z4.object({
    name: createTeamSchema.shape.name.nullish()
  })
).openapi("PatchTeam");
var createAclObjectSchema = aclObjectSchema.omit({
  id: true,
  created: true,
  _object_org_id: true
});
var createAclSchema = z4.union([
  createAclObjectSchema.merge(aclUserObjectSchema).merge(aclPrivilegeObjectSchema).openapi("CreateUserPrivilegeAcl"),
  createAclObjectSchema.merge(aclUserObjectSchema).merge(aclRoleObjectSchema).openapi("CreateUserRoleAcl"),
  createAclObjectSchema.merge(aclTeamObjectSchema).merge(aclPrivilegeObjectSchema).openapi("CreateTeamPrivilegeAcl"),
  createAclObjectSchema.merge(aclTeamObjectSchema).merge(aclRoleObjectSchema).openapi("CreateTeamRoleAcl")
]).openapi("CreateAcl");
var objectSchemas = {
  experiment: {
    create: createExperimentSchema,
    patch: patchExperimentSchema,
    object: experimentSchema
  },
  dataset: {
    create: createDatasetSchema,
    patch: patchDatasetSchema,
    object: datasetSchema
  },
  project: {
    create: createProjectSchema,
    patch: patchProjectSchema,
    object: projectSchema
  },
  prompt: {
    create: createPromptSchema,
    patch: patchPromptSchema,
    object: promptSchema
  },
  role: {
    create: createRoleSchema,
    patch: patchRoleSchema,
    object: roleSchema
  },
  team: {
    create: createTeamSchema,
    patch: patchTeamSchema,
    object: teamSchema
  },
  acl: {
    create: createAclSchema,
    patch: void 0,
    object: aclSchema
  },
  user: {
    create: void 0,
    patch: void 0,
    object: userSchema
  }
};

// src/util.ts
function capitalize(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toUpperCase() + s2.slice(1) : s2).join(sep || "");
}

// src/db_fields.ts
var TRANSACTION_ID_FIELD = "_xact_id";
var OBJECT_DELETE_FIELD = "_object_delete";
var IS_MERGE_FIELD = "_is_merge";
var MERGE_PATHS_FIELD = "_merge_paths";
var VALID_SOURCES = ["app", "api", "external"];
var PARENT_ID_FIELD = "_parent_id";

// src/span_types.ts
var SpanTypeAttribute = /* @__PURE__ */ ((SpanTypeAttribute2) => {
  SpanTypeAttribute2["LLM"] = "llm";
  SpanTypeAttribute2["SCORE"] = "score";
  SpanTypeAttribute2["FUNCTION"] = "function";
  SpanTypeAttribute2["EVAL"] = "eval";
  SpanTypeAttribute2["TASK"] = "task";
  SpanTypeAttribute2["TOOL"] = "tool";
  return SpanTypeAttribute2;
})(SpanTypeAttribute || {});

// typespecs/api_types.ts
extendZodWithOpenApi3(z5);
var auditSourcesSchema = z5.enum(VALID_SOURCES);
function generateBaseEventOpSchema(objectType) {
  const eventDescription = getEventObjectDescription(objectType);
  return z5.object({
    id: z5.string().describe(
      `A unique identifier for the ${eventDescription} event. If you don't provide one, BrainTrust will generate one for you`
    ),
    [TRANSACTION_ID_FIELD]: z5.string().describe(
      `The transaction id of an event is unique to the network operation that processed the event insertion. Transaction ids are monotonically increasing over time and can be used to retrieve a versioned snapshot of the ${eventDescription} (see the \`version\` parameter)`
    ),
    created: datetimeStringSchema.nullish().describe(`The timestamp the ${eventDescription} event was created`),
    input: customTypes.any,
    output: customTypes.any,
    expected: customTypes.any,
    tags: z5.array(z5.string()).nullish().describe("A list of tags to log"),
    scores: z5.record(z5.number().min(0).max(1).nullish()).nullish(),
    metadata: z5.record(customTypes.any).nullish().describe(
      "A dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings"
    ),
    metrics: z5.object({
      start: z5.number().nullish().describe(
        `A unix timestamp recording when the section of code which produced the ${eventDescription} event started`
      ),
      end: z5.number().nullish().describe(
        `A unix timestamp recording when the section of code which produced the ${eventDescription} event finished`
      )
    }).catchall(customTypes.any).nullish().describe(
      `Metrics are numerical measurements tracking the execution of the code that produced the ${eventDescription} event. Use "start" and "end" to track the time span over which the ${eventDescription} event was produced`
    ),
    context: z5.object({
      caller_functionname: z5.string().nullish().describe(
        `The function in code which created the ${eventDescription} event`
      ),
      caller_filename: z5.string().nullish().describe(
        `Name of the file in code where the ${eventDescription} event was created`
      ),
      caller_lineno: z5.number().int().nullish().describe(
        `Line of code where the ${eventDescription} event was created`
      )
    }).catchall(customTypes.any).nullish().describe(
      `Context is additional information about the code that produced the ${eventDescription} event. It is essentially the textual counterpart to \`metrics\`. Use the \`caller_*\` attributes to track the location in code which produced the ${eventDescription} event`
    ),
    span_id: z5.string().describe(
      `A unique identifier used to link different ${eventDescription} events together as part of a full trace. See the [tracing guide](https://www.braintrustdata.com/docs/guides/tracing) for full details on tracing`
    ),
    span_parents: z5.string().array().nullish().describe(
      `An array of the parent \`span_ids\` of this ${eventDescription} event. This should be empty for the root span of a trace, and should most often contain just one parent element for subspans`
    ),
    root_span_id: z5.string().describe(
      `The \`span_id\` of the root of the trace this ${eventDescription} event belongs to`
    ),
    span_attributes: z5.object({
      name: z5.string().nullish().describe("Name of the span, for display purposes only"),
      type: z5.nativeEnum(SpanTypeAttribute).nullish().describe("Type of the span, for display purposes only")
    }).catchall(customTypes.any).nullish().describe(
      "Human-identifying attributes of the span, such as name, type, etc."
    ),
    [OBJECT_DELETE_FIELD]: z5.boolean().nullish().describe(
      `Pass \`${OBJECT_DELETE_FIELD}=true\` to mark the ${eventDescription} event deleted. Deleted events will not show up in subsequent fetches for this ${eventDescription}`
    )
  });
}
function generateBaseEventFeedbackSchema(objectType) {
  const eventObjectType = getEventObjectType(objectType);
  const eventDescription = getEventObjectDescription(objectType);
  return z5.object({
    id: z5.string().describe(
      `The id of the ${eventDescription} event to log feedback for. This is the row \`id\` returned by \`POST /v1/${eventObjectType}/{${objectType}_id}/insert\``
    ),
    scores: z5.record(z5.number().min(0).max(1).nullish()).nullish().describe(
      `A dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the ${eventDescription} event`
    ),
    expected: customTypes.any.describe(
      "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not"
    ),
    tags: z5.array(z5.string()).nullish().describe("A list of tags to log"),
    comment: z5.string().nullish().describe(
      `An optional comment string to log about the ${eventDescription} event`
    ),
    metadata: z5.record(customTypes.any).nullish().describe(
      "A dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI."
    ),
    source: auditSourcesSchema.nullish().describe(
      'The source of the feedback. Must be one of "external" (default), "app", or "api"'
    )
  });
}
var fetchLimitSchema = z5.number().int().nonnegative().describe(
  [
    "limit the number of traces fetched",
    `Fetch queries may be paginated if the total result size is expected to be large (e.g. project_logs which accumulate over a long time). Note that fetch queries only support pagination in descending time order (from latest to earliest \`${TRANSACTION_ID_FIELD}\`. Furthermore, later pages may return rows which showed up in earlier pages, except with an earlier \`${TRANSACTION_ID_FIELD}\`. This happens because pagination occurs over the whole version history of the event log. You will most likely want to exclude any such duplicate, outdated rows (by \`id\`) from your combined result set.`,
    `The \`limit\` parameter controls the number of full traces to return. So you may end up with more individual rows than the specified limit if you are fetching events containing traces.`
  ].join("\n\n")
);
var fetchPaginationCursorDescription = [
  "Together, `max_xact_id` and `max_root_span_id` form a pagination cursor",
  `Since a paginated fetch query returns results in order from latest to earliest, the cursor for the next page can be found as the row with the minimum (earliest) value of the tuple \`(${TRANSACTION_ID_FIELD}, root_span_id)\`. See the documentation of \`limit\` for an overview of paginating fetch queries.`
].join("\n\n");
var maxXactIdSchema = z5.string().describe(fetchPaginationCursorDescription);
var maxRootSpanIdSchema = z5.string().describe(fetchPaginationCursorDescription);
var versionSchema = z5.string().describe(
  [
    "Retrieve a snapshot of events from a past time",
    "The version id is essentially a filter on the latest event transaction id. You can use the `max_xact_id` returned by a past fetch as the version to reproduce that exact fetch."
  ].join("\n\n")
);
var pathTypeFilterSchema = z5.object({
  type: z5.literal("path_lookup").describe("Denotes the type of filter as a path-lookup filter"),
  path: z5.string().array().describe(
    'List of fields describing the path to the value to be checked against. For instance, if you wish to filter on the value of `c` in `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `path=["input", "a", "b", "c"]`'
  ),
  value: customTypes.any.describe(
    'The value to compare equality-wise against the event value at the specified `path`. The value must be a "primitive", that is, any JSON-serializable object except for objects and arrays. For instance, if you wish to filter on the value of "input.a.b.c" in the object `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `value="hello"`'
  )
}).describe(
  'A path-lookup filter describes an equality comparison against a specific sub-field in the event row. For instance, if you wish to filter on the value of `c` in `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `path=["input", "a", "b", "c"]` and `value="hello"`'
).openapi("PathLookupFilter");
var sqlTypeFilterSchema = z5.object({
  type: z5.literal("sql_filter").describe("Denotes the type of filter as a sql-type filter"),
  expr: z5.string().describe(
    `A SQL expression in [duckDB syntax](https://duckdb.org/docs/sql/expressions/overview). For instance, if you wish to fuzzy-match the value of \`c\` in \`{"input": {"a": {"b": {"c": "hello"}}}}\`, pass \`expr="input->'a'->'b'->>'c' LIKE '%el%'"\`.`
  )
}).describe(
  `A sql-type filter describes a general filter over an individual row in [duckDB syntax](https://duckdb.org/docs/sql/expressions/overview). For instance, if you wish to fuzzy-match the value of \`c\` in \`{"input": {"a": {"b": {"c": "hello"}}}}\`, pass \`expr="input->'a'->'b'->>'c' LIKE '%el%'"\`.`
).openapi("SQLFilter");
var allFetchFiltersSchema = z5.union([pathTypeFilterSchema, sqlTypeFilterSchema]).array().describe(
  "A list of filters on the events to fetch. Filters can either be specialized `path=value` expressions or general SQL expressions in [duckDB syntax](https://duckdb.org/docs/sql/expressions/overview). When possible, prefer path-lookup type filters over general SQL-type filters, as they are likely to activate indices in the DB and run faster"
).openapi("AllFetchEventsFilters");
var fetchFiltersSchema = pathTypeFilterSchema.array().describe(
  "A list of filters on the events to fetch. Currently, only path-lookup type filters are supported, but we may add more in the future"
).openapi("FetchEventsFilters");
var fetchEventsRequestSchema = z5.object({
  limit: fetchLimitSchema.nullish(),
  max_xact_id: maxXactIdSchema.nullish(),
  max_root_span_id: maxRootSpanIdSchema.nullish(),
  filters: fetchFiltersSchema.nullish(),
  version: versionSchema.nullish()
}).strict().openapi("FetchEventsRequest");
function makeFetchEventsResponseSchema(objectType, eventSchema) {
  const eventName = capitalize(getEventObjectType(objectType), "_").replace(
    "_",
    ""
  );
  return z5.object({
    events: eventSchema.array().describe("A list of fetched events")
  }).strict().openapi(`Fetch${eventName}EventsResponse`);
}
var experimentEventBaseSchema = generateBaseEventOpSchema("experiment");
var experimentEventSchema = z5.object({
  id: experimentEventBaseSchema.shape.id,
  dataset_record_id: z5.string().nullish().describe(
    "If the experiment is associated to a dataset, this is the event-level dataset id this experiment event is tied to"
  ),
  [TRANSACTION_ID_FIELD]: experimentEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: experimentEventBaseSchema.shape.created,
  project_id: experimentSchema.shape.project_id,
  experiment_id: experimentSchema.shape.id,
  input: experimentEventBaseSchema.shape.input.describe(
    "The arguments that uniquely define a test case (an arbitrary, JSON serializable object). Later on, Braintrust will use the `input` to know whether two test cases are the same between experiments, so they should not contain experiment-specific state. A simple rule of thumb is that if you run the same experiment twice, the `input` should be identical"
  ),
  output: experimentEventBaseSchema.shape.output.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question"
  ),
  expected: experimentEventBaseSchema.shape.expected.describe(
    "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate your experiments while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models"
  ),
  scores: experimentEventBaseSchema.shape.scores.describe(
    "A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare experiments"
  ),
  metadata: experimentEventBaseSchema.shape.metadata,
  tags: experimentEventBaseSchema.shape.tags,
  metrics: experimentEventBaseSchema.shape.metrics,
  context: experimentEventBaseSchema.shape.context,
  span_id: experimentEventBaseSchema.shape.span_id,
  span_parents: experimentEventBaseSchema.shape.span_parents,
  root_span_id: experimentEventBaseSchema.shape.root_span_id,
  span_attributes: experimentEventBaseSchema.shape.span_attributes
}).strict().openapi("ExperimentEvent");
var datasetEventBaseSchema = generateBaseEventOpSchema("dataset");
var datasetEventSchema = z5.object({
  id: datasetEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: datasetEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: datasetEventBaseSchema.shape.created,
  project_id: datasetSchema.shape.project_id,
  dataset_id: datasetSchema.shape.id,
  input: datasetEventBaseSchema.shape.input.describe(
    "The argument that uniquely define an input case (an arbitrary, JSON serializable object)"
  ),
  expected: datasetEventBaseSchema.shape.expected.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object)"
  ),
  metadata: datasetEventBaseSchema.shape.metadata,
  tags: datasetEventBaseSchema.shape.tags,
  span_id: datasetEventBaseSchema.shape.span_id,
  root_span_id: datasetEventBaseSchema.shape.root_span_id
}).strict().openapi("DatasetEvent");
var projectLogsEventBaseSchema = generateBaseEventOpSchema("project");
var projectLogsEventSchema = z5.object({
  id: projectLogsEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: projectLogsEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: projectLogsEventBaseSchema.shape.created,
  org_id: projectSchema.shape.org_id,
  project_id: projectSchema.shape.id,
  log_id: z5.literal("g").describe("A literal 'g' which identifies the log as a project log"),
  input: projectLogsEventBaseSchema.shape.input.describe(
    "The arguments that uniquely define a user input(an arbitrary, JSON serializable object)."
  ),
  output: projectLogsEventBaseSchema.shape.output.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question."
  ),
  expected: projectLogsEventBaseSchema.shape.expected.describe(
    "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models."
  ),
  scores: projectLogsEventBaseSchema.shape.scores.describe(
    "A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare logs."
  ),
  metadata: projectLogsEventBaseSchema.shape.metadata,
  tags: projectLogsEventBaseSchema.shape.tags,
  metrics: projectLogsEventBaseSchema.shape.metrics,
  context: projectLogsEventBaseSchema.shape.context,
  span_id: projectLogsEventBaseSchema.shape.span_id,
  span_parents: projectLogsEventBaseSchema.shape.span_parents,
  root_span_id: projectLogsEventBaseSchema.shape.root_span_id,
  span_attributes: projectLogsEventBaseSchema.shape.span_attributes
}).strict().openapi("ProjectLogsEvent");
var promptEventBaseSchema = generateBaseEventOpSchema("prompt");
var promptEventSchema = z5.object({
  id: promptEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: promptEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: promptEventBaseSchema.shape.created,
  org_id: projectSchema.shape.org_id,
  project_id: projectSchema.shape.id,
  log_id: z5.literal("p").describe("A literal 'p' which identifies the log as a prompt entry"),
  name: z5.string().describe("The name of the prompt"),
  slug: z5.string().describe("The slug of the prompt"),
  description: z5.string().describe("The description of the prompt"),
  prompt_data: promptDataSchema.describe("The prompt and its parameters"),
  tags: promptEventBaseSchema.shape.tags
}).strict().openapi("PromptEvent");
var isMergeDescription = [
  "The `_is_merge` field controls how the row is merged with any existing row with the same id in the DB. By default (or when set to `false`), the existing row is completely replaced by the new row. When set to `true`, the new row is deep-merged into the existing row",
  'For example, say there is an existing row in the DB `{"id": "foo", "input": {"a": 5, "b": 10}}`. If we merge a new row as `{"_is_merge": true, "id": "foo", "input": {"b": 11, "c": 20}}`, the new row will be `{"id": "foo", "input": {"a": 5, "b": 11, "c": 20}}`. If we replace the new row as `{"id": "foo", "input": {"b": 11, "c": 20}}`, the new row will be `{"id": "foo", "input": {"b": 11, "c": 20}}`'
].join("\n\n");
var mergeEventSchema = z5.object({
  [IS_MERGE_FIELD]: customTypes.literalTrue.describe(isMergeDescription),
  [MERGE_PATHS_FIELD]: z5.string().array().array().nullish().describe(
    [
      "The `_merge_paths` field allows controlling the depth of the merge. It can only be specified alongside `_is_merge=true`. `_merge_paths` is a list of paths, where each path is a list of field names. The deep merge will not descend below any of the specified merge paths.",
      'For example, say there is an existing row in the DB `{"id": "foo", "input": {"a": {"b": 10}, "c": {"d": 20}}, "output": {"a": 20}}`. If we merge a new row as `{"_is_merge": true, "_merge_paths": [["input", "a"], ["output"]], "input": {"a": {"q": 30}, "c": {"e": 30}, "bar": "baz"}, "output": {"d": 40}}`, the new row will be `{"id": "foo": "input": {"a": {"q": 30}, "c": {"d": 20, "e": 30}, "bar": "baz"}, "output": {"d": 40}}`. In this case, due to the merge paths, we have replaced `input.a` and `output`, but have still deep-merged `input` and `input.c`.'
    ].join("\n\n")
  )
});
var replacementEventSchema = z5.object({
  [IS_MERGE_FIELD]: customTypes.literalFalse.nullish().describe(isMergeDescription),
  [PARENT_ID_FIELD]: z5.string().nullish().describe(
    [
      "Use the `_parent_id` field to create this row as a subspan of an existing row. It cannot be specified alongside `_is_merge=true`. Tracking hierarchical relationships are important for tracing (see the [guide](https://www.braintrustdata.com/docs/guides/tracing) for full details).",
      'For example, say we have logged a row `{"id": "abc", "input": "foo", "output": "bar", "expected": "boo", "scores": {"correctness": 0.33}}`. We can create a sub-span of the parent row by logging `{"_parent_id": "abc", "id": "llm_call", "input": {"prompt": "What comes after foo?"}, "output": "bar", "metrics": {"tokens": 1}}`. In the webapp, only the root span row `"abc"` will show up in the summary view. You can view the full trace hierarchy (in this case, the `"llm_call"` row) by clicking on the "abc" row.'
    ].join("\n\n")
  )
});
function makeInsertEventSchemas(objectType, insertSchema) {
  const eventDescription = getEventObjectDescription(objectType);
  const article = getObjectArticle(objectType);
  const eventSchemaName = capitalize(
    getEventObjectType(objectType),
    "_"
  ).replace("_", "");
  const replaceVariantSchema = insertSchema.merge(replacementEventSchema).strict().openapi(`Insert${eventSchemaName}EventReplace`);
  const mergeVariantSchema = insertSchema.merge(mergeEventSchema).strict().openapi(`Insert${eventSchemaName}EventMerge`);
  const eventSchema = z5.union([replaceVariantSchema, mergeVariantSchema]).describe(`${capitalize(article)} ${eventDescription} event`).openapi(`Insert${eventSchemaName}Event`);
  const requestSchema = z5.object({
    events: eventSchema.array().describe(`A list of ${eventDescription} events to insert`)
  }).strict().openapi(`Insert${eventSchemaName}EventRequest`);
  return { eventSchema, requestSchema };
}
var insertEventsResponseSchema = z5.object({
  row_ids: z5.string().array().describe(
    "The ids of all rows that were inserted, aligning one-to-one with the rows provided as input"
  )
}).strict().openapi("InsertEventsResponse");
var {
  eventSchema: insertExperimentEventSchema,
  requestSchema: insertExperimentEventsRequestSchema
} = makeInsertEventSchemas(
  "experiment",
  z5.object({
    input: experimentEventSchema.shape.input,
    output: experimentEventSchema.shape.output,
    expected: experimentEventSchema.shape.expected,
    scores: experimentEventSchema.shape.scores,
    metadata: experimentEventSchema.shape.metadata,
    tags: experimentEventSchema.shape.tags,
    metrics: experimentEventSchema.shape.metrics,
    context: experimentEventSchema.shape.context,
    span_attributes: experimentEventSchema.shape.span_attributes,
    id: experimentEventSchema.shape.id.nullish(),
    dataset_record_id: experimentEventSchema.shape.dataset_record_id,
    [OBJECT_DELETE_FIELD]: experimentEventBaseSchema.shape[OBJECT_DELETE_FIELD]
  }).strict()
);
var {
  eventSchema: insertDatasetEventSchema,
  requestSchema: insertDatasetEventsRequestSchema
} = makeInsertEventSchemas(
  "dataset",
  z5.object({
    input: datasetEventSchema.shape.input,
    expected: datasetEventSchema.shape.expected,
    metadata: datasetEventSchema.shape.metadata,
    tags: datasetEventSchema.shape.tags,
    id: datasetEventSchema.shape.id.nullish(),
    [OBJECT_DELETE_FIELD]: datasetEventBaseSchema.shape[OBJECT_DELETE_FIELD]
  }).strict()
);
var {
  eventSchema: insertProjectLogsEventSchema,
  requestSchema: insertProjectLogsEventsRequestSchema
} = makeInsertEventSchemas(
  "project",
  z5.object({
    input: projectLogsEventSchema.shape.input,
    output: projectLogsEventSchema.shape.output,
    expected: projectLogsEventSchema.shape.expected,
    scores: projectLogsEventSchema.shape.scores,
    metadata: projectLogsEventSchema.shape.metadata,
    tags: projectLogsEventSchema.shape.tags,
    metrics: projectLogsEventSchema.shape.metrics,
    context: projectLogsEventSchema.shape.context,
    span_attributes: projectLogsEventSchema.shape.span_attributes,
    id: projectLogsEventSchema.shape.id.nullish(),
    [OBJECT_DELETE_FIELD]: projectLogsEventBaseSchema.shape[OBJECT_DELETE_FIELD]
  }).strict()
);
function makeFeedbackRequestSchema(objectType, feedbackSchema) {
  const eventDescription = getEventObjectDescription(objectType);
  const eventSchemaName = capitalize(
    getEventObjectType(objectType),
    "_"
  ).replace("_", "");
  return z5.object({
    feedback: feedbackSchema.array().describe(`A list of ${eventDescription} feedback items`)
  }).strict().openapi(`Feedback${eventSchemaName}EventRequest`);
}
var feedbackExperimentRequestBaseSchema = generateBaseEventFeedbackSchema("experiment");
var feedbackExperimentItemSchema = z5.object({
  id: feedbackExperimentRequestBaseSchema.shape.id,
  scores: feedbackExperimentRequestBaseSchema.shape.scores,
  expected: feedbackExperimentRequestBaseSchema.shape.expected,
  comment: feedbackExperimentRequestBaseSchema.shape.comment,
  metadata: feedbackExperimentRequestBaseSchema.shape.metadata,
  source: feedbackExperimentRequestBaseSchema.shape.source
}).strict().openapi("FeedbackExperimentItem");
var feedbackExperimentRequestSchema = makeFeedbackRequestSchema(
  "experiment",
  feedbackExperimentItemSchema
);
var feedbackDatasetRequestBaseSchema = generateBaseEventFeedbackSchema("dataset");
var feedbackDatasetItemSchema = z5.object({
  id: feedbackDatasetRequestBaseSchema.shape.id,
  comment: feedbackDatasetRequestBaseSchema.shape.comment,
  metadata: feedbackDatasetRequestBaseSchema.shape.metadata,
  source: feedbackDatasetRequestBaseSchema.shape.source
}).strict().openapi("FeedbackDatasetItem");
var feedbackDatasetRequestSchema = makeFeedbackRequestSchema(
  "dataset",
  feedbackDatasetItemSchema
);
var feedbackProjectLogsRequestBaseSchema = generateBaseEventFeedbackSchema("project");
var feedbackProjectLogsItemSchema = z5.object({
  id: feedbackProjectLogsRequestBaseSchema.shape.id,
  scores: feedbackProjectLogsRequestBaseSchema.shape.scores,
  expected: feedbackProjectLogsRequestBaseSchema.shape.expected,
  comment: feedbackProjectLogsRequestBaseSchema.shape.comment,
  metadata: feedbackProjectLogsRequestBaseSchema.shape.metadata,
  source: feedbackProjectLogsRequestBaseSchema.shape.source
}).strict().openapi("FeedbackProjectLogsItem");
var feedbackProjectLogsRequestSchema = makeFeedbackRequestSchema(
  "project",
  feedbackProjectLogsItemSchema
);
var feedbackPromptRequestBaseSchema = generateBaseEventFeedbackSchema("prompt");
var feedbackPromptItemSchema = z5.object({
  id: feedbackPromptRequestBaseSchema.shape.id,
  comment: feedbackPromptRequestBaseSchema.shape.comment,
  metadata: feedbackPromptRequestBaseSchema.shape.metadata,
  source: feedbackPromptRequestBaseSchema.shape.source
}).strict().openapi("FeedbackPromptItem");
var feedbackPromptRequestSchema = makeFeedbackRequestSchema(
  "prompt",
  feedbackPromptItemSchema
);
var eventObjectSchemas = {
  experiment: {
    fetchResponse: makeFetchEventsResponseSchema(
      "experiment",
      experimentEventSchema
    ),
    insertEvent: insertExperimentEventSchema,
    insertRequest: insertExperimentEventsRequestSchema,
    feedbackItem: feedbackExperimentItemSchema,
    feedbackRequest: feedbackExperimentRequestSchema
  },
  dataset: {
    fetchResponse: makeFetchEventsResponseSchema("dataset", datasetEventSchema),
    insertEvent: insertDatasetEventSchema,
    insertRequest: insertDatasetEventsRequestSchema,
    feedbackItem: feedbackDatasetItemSchema,
    feedbackRequest: feedbackDatasetRequestSchema
  },
  project_logs: {
    fetchResponse: makeFetchEventsResponseSchema(
      "project",
      projectLogsEventSchema
    ),
    insertEvent: insertProjectLogsEventSchema,
    insertRequest: insertProjectLogsEventsRequestSchema,
    feedbackItem: feedbackProjectLogsItemSchema,
    feedbackRequest: feedbackProjectLogsRequestSchema
  },
  prompt: {
    fetchResponse: void 0,
    insertEvent: void 0,
    insertRequest: void 0,
    feedbackItem: feedbackPromptItemSchema,
    feedbackRequest: feedbackPromptRequestSchema
  }
};
function makeCrossObjectIndividualRequestSchema(objectType) {
  const eventObjectType = getEventObjectType(objectType);
  const eventDescription = getEventObjectDescription(objectType);
  const eventObjectSchema = eventObjectSchemas[eventObjectType];
  const insertObject = z5.object({
    ...eventObjectSchema.insertEvent ? {
      events: eventObjectSchema.insertEvent.array().nullish().describe(`A list of ${eventDescription} events to insert`)
    } : {},
    feedback: eventObjectSchema.feedbackItem.array().nullish().describe(`A list of ${eventDescription} feedback items`)
  }).strict();
  return z5.record(z5.string().uuid(), insertObject).nullish().describe(
    `A mapping from ${objectType} id to a set of log events and feedback items to insert`
  );
}
function makeCrossObjectIndividualResponseSchema(objectType) {
  return z5.record(z5.string().uuid(), insertEventsResponseSchema).nullish().describe(
    `A mapping from ${objectType} id to row ids for inserted \`events\``
  );
}
var crossObjectInsertRequestSchema = z5.object({
  experiment: makeCrossObjectIndividualRequestSchema("experiment"),
  dataset: makeCrossObjectIndividualRequestSchema("dataset"),
  project_logs: makeCrossObjectIndividualRequestSchema("project"),
  prompt: makeCrossObjectIndividualRequestSchema("prompt")
}).strict().openapi("CrossObjectInsertRequest");
var crossObjectInsertResponseSchema = z5.object({
  experiment: makeCrossObjectIndividualResponseSchema("experiment"),
  dataset: makeCrossObjectIndividualResponseSchema("dataset"),
  project_logs: makeCrossObjectIndividualResponseSchema("project"),
  prompt: makeCrossObjectIndividualResponseSchema("prompt")
}).strict().openapi("CrossObjectInsertResponse");
var summarizeScoresParamSchema = z5.boolean().describe(
  "Whether to summarize the scores and metrics. If false (or omitted), only the metadata will be returned."
);
var comparisonExperimentIdParamSchema = z5.string().uuid().describe(
  "The experiment to compare against, if summarizing scores and metrics. If omitted, will fall back to the `base_exp_id` stored in the experiment metadata, and then to the most recent experiment run in the same project. Must pass `summarize_scores=true` for this id to be used"
);
var summarizeDataParamSchema = z5.boolean().describe(
  "Whether to summarize the data. If false (or omitted), only the metadata will be returned."
);
var summarizeExperimentResponseSchema = z5.object({
  project_name: z5.string().describe("Name of the project that the experiment belongs to"),
  experiment_name: z5.string().describe("Name of the experiment"),
  project_url: z5.string().url().describe("URL to the project's page in the Braintrust app"),
  experiment_url: z5.string().url().describe("URL to the experiment's page in the Braintrust app"),
  comparison_experiment_name: z5.string().nullish().describe("The experiment which scores are baselined against"),
  scores: z5.record(
    z5.object({
      name: z5.string().describe("Name of the score"),
      score: z5.number().min(0).max(1).describe("Average score across all examples"),
      diff: z5.number().min(-1).max(1).describe(
        "Difference in score between the current and comparison experiment"
      ),
      improvements: z5.number().int().min(0).describe("Number of improvements in the score"),
      regressions: z5.number().int().min(0).describe("Number of regressions in the score")
    }).describe("Summary of a score's performance").openapi("ScoreSummary")
  ).nullish().describe("Summary of the experiment's scores"),
  metrics: z5.record(
    z5.object({
      name: z5.string().describe("Name of the metric"),
      metric: z5.number().describe("Average metric across all examples"),
      unit: z5.string().describe("Unit label for the metric"),
      diff: z5.number().describe(
        "Difference in metric between the current and comparison experiment"
      ),
      improvements: z5.number().int().min(0).describe("Number of improvements in the metric"),
      regressions: z5.number().int().min(0).describe("Number of regressions in the metric")
    }).describe("Summary of a metric's performance").openapi("MetricSummary")
  ).nullish().describe("Summary of the experiment's metrics")
}).strict().describe("Summary of an experiment").openapi("SummarizeExperimentResponse");
var summarizeDatasetResponseSchema = z5.object({
  project_name: z5.string().describe("Name of the project that the dataset belongs to"),
  dataset_name: z5.string().describe("Name of the dataset"),
  project_url: z5.string().url().describe("URL to the project's page in the Braintrust app"),
  dataset_url: z5.string().url().describe("URL to the dataset's page in the Braintrust app"),
  data_summary: z5.object({
    total_records: z5.number().int().min(0).describe("Total number of records in the dataset")
  }).nullish().describe("Summary of a dataset's data").openapi("DataSummary")
}).strict().describe("Summary of a dataset").openapi("SummarizeDatasetResponse");
var objectTypeSummarizeResponseSchemas = {
  experiment: summarizeExperimentResponseSchema,
  dataset: summarizeDatasetResponseSchema,
  project: void 0,
  prompt: void 0,
  role: void 0,
  team: void 0,
  acl: void 0,
  user: void 0
};
export {
  aclObjectSchema,
  aclObjectTypeEnum,
  aclSchema,
  allFetchFiltersSchema,
  apiKeySchema,
  appLimitSchema,
  auditSourcesSchema,
  comparisonExperimentIdParamSchema,
  crossObjectInsertRequestSchema,
  crossObjectInsertResponseSchema,
  datasetSchema,
  datetimeStringSchema,
  endingBeforeSchema,
  eventObjectSchemas,
  experimentSchema,
  fetchEventsRequestSchema,
  fetchFiltersSchema,
  fetchLimitSchema,
  functionCallSchema,
  getEventObjectDescription,
  getEventObjectType,
  getObjectArticle,
  insertEventsResponseSchema,
  jsonSchema,
  literalSchema,
  maxRootSpanIdSchema,
  maxXactIdSchema,
  meSchema,
  memberSchema,
  messageRoleSchema,
  messageSchema,
  modelParamsSchema,
  objectSchemas,
  objectTypeSummarizeResponseSchemas,
  objectTypes,
  objectTypesWithEvent,
  organizationSchema,
  projectSchema,
  promptBlockDataSchema,
  promptDataSchema,
  promptEventSchema,
  promptOptionsSchema,
  promptSchema,
  roleSchema,
  startingAfterSchema,
  summarizeDataParamSchema,
  summarizeScoresParamSchema,
  teamSchema,
  userSchema,
  versionSchema
};
