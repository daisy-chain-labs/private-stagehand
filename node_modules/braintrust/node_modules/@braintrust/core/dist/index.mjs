// src/db_fields.ts
var TRANSACTION_ID_FIELD = "_xact_id";
var OBJECT_DELETE_FIELD = "_object_delete";
var CREATED_FIELD = "created";
var ID_FIELD = "id";
var IS_MERGE_FIELD = "_is_merge";
var MERGE_PATHS_FIELD = "_merge_paths";
var AUDIT_SOURCE_FIELD = "_audit_source";
var AUDIT_METADATA_FIELD = "_audit_metadata";
var VALID_SOURCES = ["app", "api", "external"];
var PARENT_ID_FIELD = "_parent_id";
var ASYNC_SCORING_CONTROL_FIELD = "_async_scoring_control";
var SKIP_ASYNC_SCORING_FIELD = "_skip_async_scoring";

// src/http_headers.ts
var BT_FOUND_EXISTING_HEADER = "x-bt-found-existing";
var BT_CURSOR_HEADER = "x-bt-cursor";
var BT_IMPERSONATE_USER = "x-bt-impersonate-user";
var BT_PARENT = "x-bt-parent";

// src/type_util.ts
function isObject(value) {
  return value instanceof Object && !(value instanceof Array);
}
function isArray(value) {
  return value instanceof Array;
}
function isEmpty(a) {
  return a === void 0 || a === null;
}
function isNumber(a) {
  return typeof a === "number" || typeof a === "bigint";
}

// src/object_util.ts
function mergeDictsWithPaths({
  mergeInto,
  mergeFrom,
  mergePaths
}) {
  const mergePathsSerialized = new Set(
    mergePaths.map((p) => JSON.stringify(p))
  );
  return mergeDictsWithPathsHelper({
    mergeInto,
    mergeFrom,
    path: [],
    mergePaths: mergePathsSerialized
  });
}
function mergeDictsWithPathsHelper({
  mergeInto,
  mergeFrom,
  path,
  mergePaths
}) {
  Object.entries(mergeFrom).forEach(([k, mergeFromV]) => {
    const fullPath = path.concat([k]);
    const fullPathSerialized = JSON.stringify(fullPath);
    const mergeIntoV = recordFind(mergeInto, k);
    if (isObject(mergeIntoV) && isObject(mergeFromV) && !mergePaths.has(fullPathSerialized)) {
      mergeDictsWithPathsHelper({
        mergeInto: mergeIntoV,
        mergeFrom: mergeFromV,
        path: fullPath,
        mergePaths
      });
    } else {
      mergeInto[k] = mergeFromV;
    }
  });
  return mergeInto;
}
function mergeDicts(mergeInto, mergeFrom) {
  return mergeDictsWithPaths({ mergeInto, mergeFrom, mergePaths: [] });
}
function forEachMissingKey({
  lhs,
  rhs,
  fn
}) {
  function helper(lhs2, rhs2, path) {
    if (lhs2 instanceof Object) {
      if (!(rhs2 instanceof Object)) {
        return;
      }
      const lhsRec = lhs2;
      const rhsRec = rhs2;
      for (const [k, v] of Object.entries(rhsRec)) {
        if (!(k in lhsRec)) {
          fn({ lhs: lhsRec, k, v, path });
        } else {
          helper(lhsRec[k], rhsRec[k], [...path, k]);
        }
      }
    }
  }
  helper(lhs, rhs, []);
}
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}
function mapSetDefault(m, k, _default) {
  const ret = m.get(k);
  if (ret === void 0) {
    m.set(k, _default);
    return _default;
  } else {
    return ret;
  }
}
function mapSetNotPresent(m, k, v) {
  if (m.has(k)) {
    throw new Error(`Map already contains key ${k}`);
  }
  return m.set(k, v);
}
function recordFind(m, k) {
  return m[k];
}
function recordAt(m, k) {
  const ret = recordFind(m, k);
  if (ret === void 0) {
    throw new Error(`Record does not contain key ${String(k)}`);
  }
  return ret;
}
function recordSetDefault(m, k, _default) {
  const ret = recordFind(m, k);
  if (ret === void 0) {
    m[k] = _default;
    return _default;
  } else {
    return ret;
  }
}
function getRecordKeys(obj) {
  return Object.keys(obj);
}

// src/graph_util.ts
function depthFirstSearch(args) {
  var _a;
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = (_a = args.visitationOrder) != null ? _a : [...graph.keys()];
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      lastVisitF == null ? void 0 : lastVisitF(vertex);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    firstVisitF == null ? void 0 : firstVisitF(vertex, { parentVertex: extras.parentVertex });
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = (vertex, args) => {
    const label = (args == null ? void 0 : args.parentVertex) !== void 0 ? mapAt(vertexLabels, args == null ? void 0 : args.parentVertex) : labelCounter++;
    vertexLabels.set(vertex, label);
  };
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = (vertex) => {
    reverseOrdering.push(vertex);
  };
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}

// src/merge_row_batch.ts
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      (useParentIdForId != null ? useParentIdForId : false) ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
var MERGE_ROW_SKIP_FIELDS = [
  "created",
  "span_id",
  "root_span_id",
  "span_parents",
  "_parent_id"
  // TODO: handle merge paths.
];
function popMergeRowSkipFields(row) {
  const popped = {};
  for (const field of MERGE_ROW_SKIP_FIELDS) {
    if (field in row) {
      popped[field] = row[field];
      delete row[field];
    }
  }
  return popped;
}
function restoreMergeRowSkipFields(row, skipFields) {
  for (const field of MERGE_ROW_SKIP_FIELDS) {
    delete row[field];
    if (field in skipFields) {
      row[field] = skipFields[field];
    }
  }
}
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrust.dev for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const skipFields = popMergeRowSkipFields(existingRow);
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      restoreMergeRowSkipFields(existingRow, skipFields);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
function batchItems(args) {
  var _a, _b;
  let { items } = args;
  const batchMaxNumItems = (_a = args.batchMaxNumItems) != null ? _a : Number.POSITIVE_INFINITY;
  const batchMaxNumBytes = (_b = args.batchMaxNumBytes) != null ? _b : Number.POSITIVE_INFINITY;
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}

// src/object.ts
var DEFAULT_IS_LEGACY_DATASET = false;
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
function makeLegacyEvent(e) {
  if (!("dataset_id" in e) || !("expected" in e)) {
    return e;
  }
  const event = {
    ...e,
    output: e.expected
  };
  delete event.expected;
  if (MERGE_PATHS_FIELD in event) {
    for (const path of event[MERGE_PATHS_FIELD] || []) {
      if (path.length > 0 && path[0] === "expected") {
        path[0] = "output";
      }
    }
  }
  return event;
}

// src/json_util.ts
function deterministicReplacer(_key, value) {
  return value instanceof Object && !(value instanceof Array) ? Object.keys(value).sort().reduce((sorted, key) => {
    sorted[key] = value[key];
    return sorted;
  }, {}) : value;
}
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}

// src/string_util.ts
function _urljoin(...parts) {
  return parts.map(
    (x, i) => x.replace(/^\//, "").replace(i < parts.length - 1 ? /\/$/ : "", "")
  ).filter((x) => x.trim() !== "").join("/");
}
function capitalize(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toUpperCase() + s2.slice(1) : s2).join(sep || "");
}
function lowercase(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toLowerCase() + s2.slice(1) : s2).join(sep || "");
}
function snakeToCamelCase(s) {
  return s.split("_").map((s2) => capitalize(s2)).join("");
}
function snakeToTitleCase(s) {
  return capitalize(s, "_").replace("_", " ");
}
function camelToSnakeCase(s) {
  return s.replace(/([A-Z])/g, (m) => "_" + m.toLowerCase()).replace(/^_/, "");
}

// src/span_identifier_v1.ts
import * as uuid from "uuid";
import { z } from "zod";
function tryMakeUuid(s) {
  try {
    const ret = uuid.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER = 1;
var INVALID_ENCODING_ERRMSG = "SpanComponents string is not properly encoded. This may be due to a version mismatch between the SDK library used to export the span and the library used to decode it. Please make sure you are using the same SDK version across the board";
var SpanObjectTypeV1 = /* @__PURE__ */ ((SpanObjectTypeV12) => {
  SpanObjectTypeV12[SpanObjectTypeV12["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV12[SpanObjectTypeV12["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV12;
})(SpanObjectTypeV1 || {});
var SpanObjectTypeV1EnumSchema = z.nativeEnum(SpanObjectTypeV1);
var SpanRowIdsV1 = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponentsV1 = class _SpanComponentsV1 {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.rowIds = args.rowIds;
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER,
        this.objectType,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid(
      this.objectId
    );
    if (!objectIdIsUUID) {
      throw new Error("object_id component must be a valid UUID");
    }
    allBuffers.push(objectIdBytes);
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER) {
        throw new Error();
      }
      const objectType = SpanObjectTypeV1EnumSchema.parse(rawBytes[1]);
      if (![0, 1].includes(rawBytes[2])) {
        throw new Error();
      }
      if (![0, 1].includes(rawBytes[3])) {
        throw new Error();
      }
      const hasRowId = rawBytes[2] == 1;
      const rowIdIsUUID = rawBytes[3] == 1;
      const objectId = uuid.stringify(rawBytes.subarray(4, 20));
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        const spanId = uuid.stringify(rawBytes.subarray(20, 36));
        const rootSpanId = uuid.stringify(rawBytes.subarray(36, 52));
        const rowId = rowIdIsUUID ? uuid.stringify(rawBytes.subarray(52)) : rawBytes.subarray(52).toString("utf-8");
        return new SpanRowIdsV1({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponentsV1({ objectType, objectId, rowIds });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG);
    }
  }
  objectIdFields() {
    switch (this.objectType) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      rowIds: (_a = this.rowIds) == null ? void 0 : _a.toObject()
    };
  }
};

// src/span_identifier_v2.ts
import * as uuid2 from "uuid";
import { z as z2 } from "zod";
function tryMakeUuid2(s) {
  try {
    const ret = uuid2.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER2 = 2;
var INVALID_ENCODING_ERRMSG2 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER2}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
var INTEGER_ENCODING_NUM_BYTES = 4;
var SpanObjectTypeV2 = /* @__PURE__ */ ((SpanObjectTypeV22) => {
  SpanObjectTypeV22[SpanObjectTypeV22["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV22[SpanObjectTypeV22["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV22;
})(SpanObjectTypeV2 || {});
var SpanObjectTypeV2EnumSchema = z2.nativeEnum(SpanObjectTypeV2);
var SpanRowIdsV2 = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponentsV2 = class _SpanComponentsV2 {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.computeObjectMetadataArgs = args.computeObjectMetadataArgs;
    this.rowIds = args.rowIds;
    if (!(this.objectId || this.computeObjectMetadataArgs)) {
      throw new Error(
        "Must provide either objectId or computeObjectMetadataArgs"
      );
    }
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid2(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER2,
        this.objectType,
        this.objectId ? 1 : 0,
        this.computeObjectMetadataArgs ? 1 : 0,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    if (this.objectId) {
      const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid2(
        this.objectId
      );
      if (!objectIdIsUUID) {
        throw new Error("object_id component must be a valid UUID");
      }
      allBuffers.push(objectIdBytes);
    }
    if (this.computeObjectMetadataArgs) {
      const computeObjectMetadataBytes = Buffer.from(
        JSON.stringify(this.computeObjectMetadataArgs),
        "utf-8"
      );
      const serializedLenBytes = Buffer.alloc(INTEGER_ENCODING_NUM_BYTES);
      serializedLenBytes.writeInt32BE(computeObjectMetadataBytes.length);
      allBuffers.push(serializedLenBytes, computeObjectMetadataBytes);
    }
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid2(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid2(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] < ENCODING_VERSION_NUMBER2) {
        const spanComponentsOld = SpanComponentsV1.fromStr(s);
        return new _SpanComponentsV2({
          objectType: SpanObjectTypeV2EnumSchema.parse(
            spanComponentsOld.objectType
          ),
          objectId: spanComponentsOld.objectId,
          rowIds: spanComponentsOld.rowIds ? new SpanRowIdsV2({
            rowId: spanComponentsOld.rowIds.rowId,
            spanId: spanComponentsOld.rowIds.spanId,
            rootSpanId: spanComponentsOld.rowIds.rootSpanId
          }) : void 0
        });
      }
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER2) {
        throw new Error();
      }
      const objectType = SpanObjectTypeV2EnumSchema.parse(rawBytes[1]);
      for (let i = 2; i < 6; ++i) {
        if (![0, 1].includes(rawBytes[i])) {
          throw new Error();
        }
      }
      const hasObjectId = rawBytes[2] == 1;
      const hasComputeObjectMetadataArgs = rawBytes[3] == 1;
      const hasRowId = rawBytes[4] == 1;
      const rowIdIsUUID = rawBytes[5] == 1;
      let byteCursor = 6;
      let objectId = void 0;
      if (hasObjectId) {
        const nextByteCursor = byteCursor + 16;
        objectId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
      }
      let computeObjectMetadataArgs;
      if (hasComputeObjectMetadataArgs) {
        let nextByteCursor = byteCursor + INTEGER_ENCODING_NUM_BYTES;
        const serializedLenBytes = rawBytes.readInt32BE(byteCursor);
        byteCursor = nextByteCursor;
        nextByteCursor = byteCursor + serializedLenBytes;
        computeObjectMetadataArgs = JSON.parse(
          rawBytes.subarray(byteCursor, nextByteCursor).toString("utf-8")
        );
        byteCursor = nextByteCursor;
      }
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        let nextByteCursor = byteCursor + 16;
        const spanId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
        nextByteCursor = byteCursor + 16;
        const rootSpanId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
        const rowId = rowIdIsUUID ? uuid2.stringify(rawBytes.subarray(byteCursor)) : rawBytes.subarray(byteCursor).toString("utf-8");
        return new SpanRowIdsV2({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponentsV2({
        objectType,
        objectId,
        computeObjectMetadataArgs,
        rowIds
      });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG2);
    }
  }
  objectIdFields() {
    if (!this.objectId) {
      throw new Error(
        "Impossible: cannot invoke `object_id_fields` unless SpanComponentsV2 is initialized with an `object_id`"
      );
    }
    switch (this.objectType) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      computeObjectMetadataArgs: this.computeObjectMetadataArgs,
      rowIds: (_a = this.rowIds) == null ? void 0 : _a.toObject()
    };
  }
};

// src/span_identifier_v3.ts
import * as uuid3 from "uuid";
import { z as z3 } from "zod";
function tryMakeUuid3(s) {
  try {
    const ret = uuid3.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: void 0, isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER3 = 3;
var INVALID_ENCODING_ERRMSG3 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER3}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
var SpanObjectTypeV3 = /* @__PURE__ */ ((SpanObjectTypeV32) => {
  SpanObjectTypeV32[SpanObjectTypeV32["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV32[SpanObjectTypeV32["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV32;
})(SpanObjectTypeV3 || {});
var spanObjectTypeV3EnumSchema = z3.nativeEnum(SpanObjectTypeV3);
function spanObjectTypeV3ToString(objectType) {
  switch (objectType) {
    case 1 /* EXPERIMENT */:
      return "experiment";
    case 2 /* PROJECT_LOGS */:
      return "project_logs";
    default:
      const x = objectType;
      throw new Error(`Unknown SpanObjectTypeV3: ${x}`);
  }
}
var InternalSpanComponentUUIDFields = /* @__PURE__ */ ((InternalSpanComponentUUIDFields2) => {
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["OBJECT_ID"] = 1] = "OBJECT_ID";
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROW_ID"] = 2] = "ROW_ID";
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["SPAN_ID"] = 3] = "SPAN_ID";
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROOT_SPAN_ID"] = 4] = "ROOT_SPAN_ID";
  return InternalSpanComponentUUIDFields2;
})(InternalSpanComponentUUIDFields || {});
var internalSpanComponentUUIDFieldsEnumSchema = z3.nativeEnum(
  InternalSpanComponentUUIDFields
);
var _INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME = {
  [1 /* OBJECT_ID */]: "object_id",
  [2 /* ROW_ID */]: "row_id",
  [3 /* SPAN_ID */]: "span_id",
  [4 /* ROOT_SPAN_ID */]: "root_span_id"
};
var spanComponentsV3Schema = z3.object({
  object_type: spanObjectTypeV3EnumSchema,
  // TODO(manu): We should have a more elaborate zod schema for
  // `propagated_event`. This will required zod-ifying the contents of
  // sdk/core/js/src/object.ts.
  propagated_event: z3.record(z3.unknown()).nullish()
}).and(
  z3.union([
    // Must provide one or the other.
    z3.object({
      object_id: z3.string().nullish(),
      compute_object_metadata_args: z3.optional(z3.null())
    }),
    z3.object({
      object_id: z3.optional(z3.null()),
      compute_object_metadata_args: z3.record(z3.unknown())
    })
  ])
).and(
  z3.union([
    // Either all of these must be provided or none.
    z3.object({
      row_id: z3.string(),
      span_id: z3.string(),
      root_span_id: z3.string()
    }),
    z3.object({
      row_id: z3.optional(z3.null()),
      span_id: z3.optional(z3.null()),
      root_span_id: z3.optional(z3.null())
    })
  ])
);
var SpanComponentsV3 = class _SpanComponentsV3 {
  constructor(data) {
    this.data = data;
  }
  toStr() {
    const jsonObj = {
      compute_object_metadata_args: this.data.compute_object_metadata_args || void 0,
      propagated_event: this.data.propagated_event || void 0
    };
    const allBuffers = [];
    allBuffers.push(
      Buffer.from([ENCODING_VERSION_NUMBER3, this.data.object_type])
    );
    const uuidEntries = [];
    function addUuidField(origVal, fieldId) {
      const ret = tryMakeUuid3(origVal);
      if (ret.isUUID) {
        uuidEntries.push(Buffer.concat([Buffer.from([fieldId]), ret.bytes]));
      } else {
        jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = origVal;
      }
    }
    if (this.data.object_id) {
      addUuidField(
        this.data.object_id,
        1 /* OBJECT_ID */
      );
    }
    if (this.data.row_id) {
      addUuidField(this.data.row_id, 2 /* ROW_ID */);
    }
    if (this.data.span_id) {
      addUuidField(this.data.span_id, 3 /* SPAN_ID */);
    }
    if (this.data.root_span_id) {
      addUuidField(
        this.data.root_span_id,
        4 /* ROOT_SPAN_ID */
      );
    }
    if (uuidEntries.length > 255) {
      throw new Error("Impossible: too many UUID entries to encode");
    }
    allBuffers.push(Buffer.from([uuidEntries.length]));
    allBuffers.push(...uuidEntries);
    if (Object.keys(jsonObj).length > 0) {
      allBuffers.push(Buffer.from(JSON.stringify(jsonObj), "utf-8"));
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      const jsonObj = {};
      if (rawBytes[0] < ENCODING_VERSION_NUMBER3) {
        const spanComponentsOld = SpanComponentsV2.fromStr(s);
        jsonObj["object_type"] = spanComponentsOld.objectType;
        jsonObj["object_id"] = spanComponentsOld.objectId;
        jsonObj["compute_object_metadata_args"] = spanComponentsOld.computeObjectMetadataArgs;
        if (spanComponentsOld.rowIds) {
          jsonObj["row_id"] = spanComponentsOld.rowIds.rowId;
          jsonObj["span_id"] = spanComponentsOld.rowIds.spanId;
          jsonObj["root_span_id"] = spanComponentsOld.rowIds.rootSpanId;
        }
      } else {
        jsonObj["object_type"] = rawBytes[1];
        const numUuidEntries = rawBytes[2];
        let byteOffset = 3;
        for (let i = 0; i < numUuidEntries; ++i) {
          const fieldId = internalSpanComponentUUIDFieldsEnumSchema.parse(
            rawBytes[byteOffset]
          );
          const fieldBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
          byteOffset += 17;
          jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = uuid3.stringify(fieldBytes);
        }
        if (byteOffset < rawBytes.length) {
          const remainingJsonObj = JSON.parse(
            rawBytes.subarray(byteOffset).toString("utf-8")
          );
          Object.assign(jsonObj, remainingJsonObj);
        }
      }
      return _SpanComponentsV3.fromJsonObj(jsonObj);
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG3);
    }
  }
  objectIdFields() {
    if (!this.data.object_id) {
      throw new Error(
        "Impossible: cannot invoke `objectIdFields` unless SpanComponentsV3 is initialized with an `object_id`"
      );
    }
    switch (this.data.object_type) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.data.object_id };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.data.object_id, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  static fromJsonObj(jsonObj) {
    return new _SpanComponentsV3(spanComponentsV3Schema.parse(jsonObj));
  }
};

// src/span_types.ts
var spanTypeAttributeValues = [
  "llm",
  "score",
  "function",
  "eval",
  "task",
  "tool"
];
var SpanTypeAttribute = /* @__PURE__ */ ((SpanTypeAttribute2) => {
  SpanTypeAttribute2["LLM"] = "llm";
  SpanTypeAttribute2["SCORE"] = "score";
  SpanTypeAttribute2["FUNCTION"] = "function";
  SpanTypeAttribute2["EVAL"] = "eval";
  SpanTypeAttribute2["TASK"] = "task";
  SpanTypeAttribute2["TOOL"] = "tool";
  return SpanTypeAttribute2;
})(SpanTypeAttribute || {});
var spanPurposeAttributeValues = ["scorer"];

// src/git_fields.ts
function mergeGitMetadataSettings(s1, s2) {
  var _a;
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = ((_a = s1.fields) != null ? _a : []).filter((f) => {
    var _a2;
    return ((_a2 = s2.fields) != null ? _a2 : []).includes(f);
  });
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}

// src/xact-ids.ts
var TOP_BITS = BigInt("0x0DE1") << BigInt(48);
var MOD = BigInt(1) << BigInt(64);
var COPRIME = BigInt("205891132094649");
var COPRIME_INVERSE = BigInt("1522336535492693385");
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
function loadPrettyXact(encodedHex) {
  if (encodedHex.length !== 16) {
    return encodedHex;
  }
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}

// src/zod_util.ts
import { z as z4 } from "zod";
var ExtraFieldsError = class extends Error {
  constructor(key, path) {
    super(
      `Extraneous key ${JSON.stringify(key)} at path ${JSON.stringify(path)}`
    );
    this.key = key;
    this.path = path;
  }
};
function parseNoStrip(schema, input) {
  const output = schema.parse(input);
  forEachMissingKey({
    lhs: output,
    rhs: input,
    fn: ({ k, path }) => {
      throw new ExtraFieldsError(k, path);
    }
  });
  return output;
}
function objectNullish(object) {
  return new z4.ZodObject({
    ...object._def,
    shape: () => Object.fromEntries(
      Object.entries(object.shape).map(([k, v]) => [k, v.nullish()])
    )
  });
}
export {
  ASYNC_SCORING_CONTROL_FIELD,
  AUDIT_METADATA_FIELD,
  AUDIT_SOURCE_FIELD,
  BT_CURSOR_HEADER,
  BT_FOUND_EXISTING_HEADER,
  BT_IMPERSONATE_USER,
  BT_PARENT,
  CREATED_FIELD,
  DEFAULT_IS_LEGACY_DATASET,
  ExtraFieldsError,
  ID_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD,
  PARENT_ID_FIELD,
  SKIP_ASYNC_SCORING_FIELD,
  SpanComponentsV1,
  SpanComponentsV2,
  SpanComponentsV3,
  SpanObjectTypeV1,
  SpanObjectTypeV2,
  SpanObjectTypeV3,
  SpanRowIdsV1,
  SpanRowIdsV2,
  SpanTypeAttribute,
  TRANSACTION_ID_FIELD,
  VALID_SOURCES,
  _urljoin,
  batchItems,
  camelToSnakeCase,
  capitalize,
  constructJsonArray,
  deterministicReplacer,
  ensureDatasetRecord,
  ensureLegacyDatasetRecord,
  ensureNewDatasetRecord,
  forEachMissingKey,
  getRecordKeys,
  isArray,
  isEmpty,
  isNumber,
  isObject,
  loadPrettyXact,
  lowercase,
  makeLegacyEvent,
  mapAt,
  mapSetDefault,
  mapSetNotPresent,
  mergeDicts,
  mergeDictsWithPaths,
  mergeGitMetadataSettings,
  mergeRowBatch,
  objectNullish,
  parseNoStrip,
  prettifyXact,
  recordAt,
  recordFind,
  recordSetDefault,
  snakeToCamelCase,
  snakeToTitleCase,
  spanComponentsV3Schema,
  spanObjectTypeV3EnumSchema,
  spanObjectTypeV3ToString,
  spanPurposeAttributeValues,
  spanTypeAttributeValues
};
