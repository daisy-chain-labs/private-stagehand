/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as AnonApi from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace AppUserIdToken {
  interface Options {
    environment?: core.Supplier<environments.AnonApiEnvironment | string>;
    token: core.Supplier<core.BearerToken>;
    /** Override the X-Anon-Sdk-Client-Id header */
    anonSdkClientId: core.Supplier<string>;
  }

  interface RequestOptions {
    /** The maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** A hook to abort the request. */
    abortSignal?: AbortSignal;
    /** Override the X-Anon-Sdk-Client-Id header */
    anonSdkClientId?: string;
    /** Additional headers to include in the request. */
    headers?: Record<string, string>;
  }
}

export class AppUserIdToken {
  constructor(protected readonly _options: AppUserIdToken.Options) {}

  /**
   * Issues a new `AppUserIdToken` to be used as a bearer token for authenticating app user traffic. **Can only be used with Anon-hosted UserPools**. In this case, Anon serves as your identity provider, issuing and validating tokens for your users. For each app user you want to connect to Anon, call this endpoint with that user's ID to issue an AppUserIdToken that they can use for authentication with Anon. This credential is sensitive and can be used to access that user's sessions, so it should be stored securely or not at all. You may call this route whenever you need to issue a new AppUserIdToken (for example, upon login or token expiration). Duplicate calls with the same user ID will refresh the expiration, but will have no other effects. Takes an optional `exp`iration; this defaults to 6 months from time of issuing.
   *
   * @param {AnonApi.CreateAppUserIdToken} request
   * @param {AppUserIdToken.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @example
   *     await client.appUserIdToken.createAppUserIdToken({
   *         appUserId: "string",
   *         exp: 1
   *     })
   */
  public async createAppUserIdToken(
    request: AnonApi.CreateAppUserIdToken,
    requestOptions?: AppUserIdToken.RequestOptions,
  ): Promise<AnonApi.AppUserIdToken> {
    const _response = await core.fetcher({
      url: urlJoin(
        (await core.Supplier.get(this._options.environment)) ??
          environments.AnonApiEnvironment.Sandbox,
        "/org/appUserIdToken",
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader(),
        "X-Anon-Sdk-Client-Id": await core.Supplier.get(
          this._options.anonSdkClientId,
        ),
        "X-Fern-Language": "JavaScript",
        "X-Fern-Runtime": core.RUNTIME.type,
        "X-Fern-Runtime-Version": core.RUNTIME.version,
        ...requestOptions?.headers,
      },
      contentType: "application/json",
      requestType: "json",
      body: request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
    });
    if (_response.ok) {
      return _response.body as AnonApi.AppUserIdToken;
    }

    if (_response.error.reason === "status-code") {
      throw new errors.AnonApiError({
        statusCode: _response.error.statusCode,
        body: _response.error.body,
      });
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.AnonApiError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
        });
      case "timeout":
        throw new errors.AnonApiTimeoutError(
          "Timeout exceeded when calling POST /org/appUserIdToken.",
        );
      case "unknown":
        throw new errors.AnonApiError({
          message: _response.error.errorMessage,
        });
    }
  }

  protected async _getAuthorizationHeader(): Promise<string> {
    return `Bearer ${await core.Supplier.get(this._options.token)}`;
  }
}
