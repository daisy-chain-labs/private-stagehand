"use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppUserIdToken = void 0;
const environments = __importStar(require("../../../../environments"));
const core = __importStar(require("../../../../core"));
const url_join_1 = __importDefault(require("url-join"));
const errors = __importStar(require("../../../../errors/index"));
class AppUserIdToken {
    _options;
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Issues a new `AppUserIdToken` to be used as a bearer token for authenticating app user traffic. **Can only be used with Anon-hosted UserPools**. In this case, Anon serves as your identity provider, issuing and validating tokens for your users. For each app user you want to connect to Anon, call this endpoint with that user's ID to issue an AppUserIdToken that they can use for authentication with Anon. This credential is sensitive and can be used to access that user's sessions, so it should be stored securely or not at all. You may call this route whenever you need to issue a new AppUserIdToken (for example, upon login or token expiration). Duplicate calls with the same user ID will refresh the expiration, but will have no other effects. Takes an optional `exp`iration; this defaults to 6 months from time of issuing.
     *
     * @param {AnonApi.CreateAppUserIdToken} request
     * @param {AppUserIdToken.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.appUserIdToken.createAppUserIdToken({
     *         appUserId: "string",
     *         exp: 1
     *     })
     */
    async createAppUserIdToken(request, requestOptions) {
        const _response = await core.fetcher({
            url: (0, url_join_1.default)((await core.Supplier.get(this._options.environment)) ??
                environments.AnonApiEnvironment.Sandbox, "/org/appUserIdToken"),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Anon-Sdk-Client-Id": await core.Supplier.get(this._options.anonSdkClientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null
                ? requestOptions.timeoutInSeconds * 1000
                : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }
        if (_response.error.reason === "status-code") {
            throw new errors.AnonApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AnonApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.AnonApiTimeoutError("Timeout exceeded when calling POST /org/appUserIdToken.");
            case "unknown":
                throw new errors.AnonApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
    async _getAuthorizationHeader() {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
exports.AppUserIdToken = AppUserIdToken;
//# sourceMappingURL=Client.js.map