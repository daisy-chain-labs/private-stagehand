"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodePre18StreamWrapper = void 0;
class NodePre18StreamWrapper {
    readableStream;
    encoding;
    constructor(readableStream) {
        this.readableStream = readableStream;
    }
    on(event, callback) {
        this.readableStream.on(event, callback);
    }
    off(event, callback) {
        this.readableStream.off(event, callback);
    }
    pipe(dest) {
        this.readableStream.pipe(dest);
        return dest;
    }
    pipeTo(dest) {
        return this.pipe(dest);
    }
    unpipe(dest) {
        if (dest) {
            this.readableStream.unpipe(dest);
        }
        else {
            this.readableStream.unpipe();
        }
    }
    destroy(error) {
        this.readableStream.destroy(error);
    }
    pause() {
        this.readableStream.pause();
    }
    resume() {
        this.readableStream.resume();
    }
    get isPaused() {
        return this.readableStream.isPaused();
    }
    async read() {
        return new Promise((resolve, reject) => {
            const chunk = this.readableStream.read();
            if (chunk) {
                resolve(chunk);
            }
            else {
                this.readableStream.once("readable", () => {
                    const chunk = this.readableStream.read();
                    resolve(chunk);
                });
                this.readableStream.once("error", reject);
            }
        });
    }
    setEncoding(encoding) {
        this.readableStream.setEncoding(encoding);
        this.encoding = encoding;
    }
    async text() {
        const chunks = [];
        const encoder = new TextEncoder();
        this.readableStream.setEncoding((this.encoding || "utf-8"));
        for await (const chunk of this.readableStream) {
            chunks.push(encoder.encode(chunk));
        }
        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(Buffer.concat(chunks));
    }
    async json() {
        const text = await this.text();
        return JSON.parse(text);
    }
    [Symbol.asyncIterator]() {
        const readableStream = this.readableStream;
        const iterator = readableStream[Symbol.asyncIterator]();
        // Create and return an async iterator that yields buffers
        return {
            async next() {
                const { value, done } = await iterator.next();
                return { value: value, done };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
exports.NodePre18StreamWrapper = NodePre18StreamWrapper;
//# sourceMappingURL=NodePre18StreamWrapper.js.map