"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node18UniversalStreamWrapper = void 0;
class Node18UniversalStreamWrapper {
    readableStream;
    reader;
    events;
    paused;
    resumeCallback;
    encoding;
    constructor(readableStream) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: [],
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }
    on(event, callback) {
        this.events[event]?.push(callback);
    }
    off(event, callback) {
        this.events[event] = this.events[event]?.filter((cb) => cb !== callback);
    }
    pipe(dest) {
        this.on("data", async (chunk) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._write(chunk);
            }
            else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.write(chunk).then(() => writer.releaseLock());
            }
            else {
                dest.write(chunk);
            }
        });
        this.on("end", async () => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._end();
            }
            else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.close();
            }
            else {
                dest.end();
            }
        });
        this.on("error", async (error) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._error(error);
            }
            else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.abort(error);
            }
            else {
                dest.destroy(error);
            }
        });
        this._startReading();
        return dest;
    }
    pipeTo(dest) {
        return this.pipe(dest);
    }
    unpipe(dest) {
        this.off("data", async (chunk) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._write(chunk);
            }
            else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.write(chunk).then(() => writer.releaseLock());
            }
            else {
                dest.write(chunk);
            }
        });
        this.off("end", async () => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._end();
            }
            else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.close();
            }
            else {
                dest.end();
            }
        });
        this.off("error", async (error) => {
            if (dest instanceof Node18UniversalStreamWrapper) {
                dest._error(error);
            }
            else if (dest instanceof WritableStream) {
                const writer = dest.getWriter();
                writer.abort(error);
            }
            else {
                dest.destroy(error);
            }
        });
    }
    destroy(error) {
        this.reader
            .cancel(error)
            .then(() => {
            this._emit("close");
        })
            .catch((err) => {
            this._emit("error", err);
        });
    }
    pause() {
        this.paused = true;
        this._emit("pause");
    }
    resume() {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }
    get isPaused() {
        return this.paused;
    }
    async read() {
        if (this.paused) {
            await new Promise((resolve) => {
                this.resumeCallback = resolve;
            });
        }
        const { done, value } = await this.reader.read();
        if (done) {
            return undefined;
        }
        return value;
    }
    setEncoding(encoding) {
        this.encoding = encoding;
    }
    async text() {
        const chunks = [];
        while (true) {
            const { done, value } = await this.reader.read();
            if (done) {
                break;
            }
            if (value) {
                chunks.push(value);
            }
        }
        const decoder = new TextDecoder(this.encoding || "utf-8");
        return decoder.decode(await new Blob(chunks).arrayBuffer());
    }
    async json() {
        const text = await this.text();
        return JSON.parse(text);
    }
    _write(chunk) {
        this._emit("data", chunk);
    }
    _end() {
        this._emit("end");
    }
    _error(error) {
        this._emit("error", error);
    }
    _emit(event, data) {
        if (this.events[event]) {
            for (const callback of this.events[event] || []) {
                callback(data);
            }
        }
    }
    async _startReading() {
        try {
            this._emit("readable");
            while (true) {
                if (this.paused) {
                    await new Promise((resolve) => {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    this._emit("end");
                    this._emit("close");
                    break;
                }
                if (value) {
                    this._emit("data", value);
                }
            }
        }
        catch (error) {
            this._emit("error", error);
        }
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                if (this.paused) {
                    await new Promise((resolve) => {
                        this.resumeCallback = resolve;
                    });
                }
                const { done, value } = await this.reader.read();
                if (done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
exports.Node18UniversalStreamWrapper = Node18UniversalStreamWrapper;
//# sourceMappingURL=Node18UniversalStreamWrapper.js.map