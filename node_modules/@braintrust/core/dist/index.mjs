// src/db_fields.ts
var TRANSACTION_ID_FIELD = "_xact_id";
var OBJECT_DELETE_FIELD = "_object_delete";
var CREATED_FIELD = "created";
var ID_FIELD = "id";
var IS_MERGE_FIELD = "_is_merge";
var MERGE_PATHS_FIELD = "_merge_paths";
var AUDIT_SOURCE_FIELD = "_audit_source";
var AUDIT_METADATA_FIELD = "_audit_metadata";
var VALID_SOURCES = ["app", "api", "external"];
var PARENT_ID_FIELD = "_parent_id";
var ALL_ROW_ID_FIELDS = [
  ID_FIELD,
  TRANSACTION_ID_FIELD,
  CREATED_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD
];

// src/util.ts
function mergeDicts(mergeInto, mergeFrom) {
  for (const [k, mergeFromV] of Object.entries(mergeFrom)) {
    const mergeIntoV = mergeInto[k];
    if (mergeIntoV instanceof Object && !Array.isArray(mergeIntoV) && mergeFrom instanceof Object && !Array.isArray(mergeFromV)) {
      mergeDicts(
        mergeIntoV,
        mergeFromV
      );
    } else {
      mergeInto[k] = mergeFromV;
    }
  }
  return mergeInto;
}
function capitalize(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toUpperCase() + s2.slice(1) : s2).join(sep || "");
}
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}

// src/graph_util.ts
function depthFirstSearch(args) {
  var _a;
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = (_a = args.visitationOrder) != null ? _a : [...graph.keys()];
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      lastVisitF == null ? void 0 : lastVisitF(vertex);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    firstVisitF == null ? void 0 : firstVisitF(vertex, { parentVertex: extras.parentVertex });
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = (vertex, args) => {
    const label = (args == null ? void 0 : args.parentVertex) !== void 0 ? mapAt(vertexLabels, args == null ? void 0 : args.parentVertex) : labelCounter++;
    vertexLabels.set(vertex, label);
  };
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = (vertex) => {
    reverseOrdering.push(vertex);
  };
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}

// src/merge_row_batch.ts
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      (useParentIdForId != null ? useParentIdForId : false) ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrustdata.com for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
function batchItems(args) {
  var _a, _b;
  let { items } = args;
  const batchMaxNumItems = (_a = args.batchMaxNumItems) != null ? _a : Number.POSITIVE_INFINITY;
  const batchMaxNumBytes = (_b = args.batchMaxNumBytes) != null ? _b : Number.POSITIVE_INFINITY;
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}

// src/object.ts
var DEFAULT_IS_LEGACY_DATASET = true;
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
function makeLegacyEvent(e) {
  if (!("dataset_id" in e) || !("expected" in e)) {
    return e;
  }
  const event = {
    ...e,
    output: e.expected
  };
  delete event.expected;
  if (MERGE_PATHS_FIELD in event) {
    for (const path of event[MERGE_PATHS_FIELD] || []) {
      if (path.length > 0 && path[0] === "expected") {
        path[0] = "output";
      }
    }
  }
  return event;
}

// src/span_identifier.ts
import * as uuid from "uuid";
import { z } from "zod";
function tryMakeUuid(s) {
  try {
    const ret = uuid.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER = 1;
var INVALID_ENCODING_ERRMSG = "SpanComponents string is not properly encoded. This may be due to a version mismatch between the SDK library used to export the span and the library used to decode it. Please make sure you are using the same SDK version across the board";
var SpanObjectType = /* @__PURE__ */ ((SpanObjectType2) => {
  SpanObjectType2[SpanObjectType2["EXPERIMENT"] = 0] = "EXPERIMENT";
  SpanObjectType2[SpanObjectType2["PROJECT_LOGS"] = 1] = "PROJECT_LOGS";
  return SpanObjectType2;
})(SpanObjectType || {});
var SpanObjectTypeEnumSchema = z.nativeEnum(SpanObjectType);
var SpanRowIds = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponents = class _SpanComponents {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.rowIds = args.rowIds;
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER,
        this.objectType,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid(
      this.objectId
    );
    if (!objectIdIsUUID) {
      throw new Error("object_id component must be a valid UUID");
    }
    allBuffers.push(objectIdBytes);
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER) {
        throw new Error();
      }
      const objectType = SpanObjectTypeEnumSchema.parse(rawBytes[1]);
      if (![0, 1].includes(rawBytes[2])) {
        throw new Error();
      }
      if (![0, 1].includes(rawBytes[3])) {
        throw new Error();
      }
      const hasRowId = rawBytes[2] == 1;
      const rowIdIsUUID = rawBytes[3] == 1;
      const objectId = uuid.stringify(rawBytes.subarray(4, 20));
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        const spanId = uuid.stringify(rawBytes.subarray(20, 36));
        const rootSpanId = uuid.stringify(rawBytes.subarray(36, 52));
        const rowId = rowIdIsUUID ? uuid.stringify(rawBytes.subarray(52)) : rawBytes.subarray(52).toString("utf-8");
        return new SpanRowIds({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponents({ objectType, objectId, rowIds });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG);
    }
  }
  objectIdFields() {
    switch (this.objectType) {
      case 0 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 1 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      rowIds: (_a = this.rowIds) == null ? void 0 : _a.toObject()
    };
  }
};

// src/span_types.ts
var spanTypeAttributeValues = [
  "llm",
  "score",
  "function",
  "eval",
  "task",
  "tool"
];
var SpanTypeAttribute = /* @__PURE__ */ ((SpanTypeAttribute2) => {
  SpanTypeAttribute2["LLM"] = "llm";
  SpanTypeAttribute2["SCORE"] = "score";
  SpanTypeAttribute2["FUNCTION"] = "function";
  SpanTypeAttribute2["EVAL"] = "eval";
  SpanTypeAttribute2["TASK"] = "task";
  SpanTypeAttribute2["TOOL"] = "tool";
  return SpanTypeAttribute2;
})(SpanTypeAttribute || {});

// src/git_fields.ts
function mergeGitMetadataSettings(s1, s2) {
  var _a;
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = ((_a = s1.fields) != null ? _a : []).filter((f) => {
    var _a2;
    return ((_a2 = s2.fields) != null ? _a2 : []).includes(f);
  });
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}

// src/xact-ids.ts
var TOP_BITS = BigInt("0x0DE1") << BigInt(48);
var MOD = BigInt(1) << BigInt(64);
var COPRIME = BigInt("205891132094649");
var COPRIME_INVERSE = BigInt("1522336535492693385");
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
function loadPrettyXact(encodedHex) {
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}
export {
  ALL_ROW_ID_FIELDS,
  AUDIT_METADATA_FIELD,
  AUDIT_SOURCE_FIELD,
  CREATED_FIELD,
  DEFAULT_IS_LEGACY_DATASET,
  ID_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD,
  PARENT_ID_FIELD,
  SpanComponents,
  SpanObjectType,
  SpanRowIds,
  SpanTypeAttribute,
  TRANSACTION_ID_FIELD,
  VALID_SOURCES,
  batchItems,
  capitalize,
  constructJsonArray,
  ensureDatasetRecord,
  ensureLegacyDatasetRecord,
  ensureNewDatasetRecord,
  loadPrettyXact,
  makeLegacyEvent,
  mapAt,
  mergeDicts,
  mergeGitMetadataSettings,
  mergeRowBatch,
  prettifyXact,
  spanTypeAttributeValues
};
